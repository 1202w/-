package class100;

// KMP算法模版
// 测试链接 : https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/
public class Code01_KMP {

	public static int strStr(String s1, String s2) {
		// return s1.indexOf(s2);
		return kmp(s1.toCharArray(), s2.toCharArray());
	}

	// KMP算法
	public static int kmp(char[] s1, char[] s2) {
		// s1中当前比对的位置是x
		// s2中当前比对的位置是y
		int n = s1.length, m = s2.length, x = 0, y = 0;
		// O(m)
		int[] next = nextArray(s2, m);
		// O(n)
		while (x < n && y < m) {
			if (s1[x] == s2[y]) {
				x++;
				y++;
			} else if (y == 0) {
				x++;
			} else {
				y = next[y];
			}
		}
		return y == m ? x - y : -1;
	}

	// 得到next数组
	public static int[] nextArray(char[] s, int m) {
		if (m == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[m];
		next[0] = -1;
		next[1] = 0;
		// i表示当前要求next值的位置
		// cn表示当前要和前一个字符比对的下标
		int i = 2, cn = 0;
		while (i < m) {
			if (s[i - 1] == s[cn]) {
				next[i++] = ++cn;
			} else if (cn > 0) {
				cn = next[cn];
			} else {
				next[i++] = 0;
			}
		}
		return next;
	}

}

package class102;

// AC自动机模版(优化版)
// 给你若干目标字符串，还有一篇文章
// 返回每个目标字符串在文章中出现了几次
// 测试链接 : https://www.luogu.com.cn/problem/P5357
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code01_ACAM {

	// 目标字符串的数量
	public static int MAXN = 200001;

	// 所有目标字符串的总字符数量
	public static int MAXS = 200001;

	// 记录每个目标串的结尾节点编号
	public static int[] end = new int[MAXN];

	// AC自动机
	public static int[][] tree = new int[MAXS][26];

	public static int[] fail = new int[MAXS];

	public static int cnt = 0;

	// 具体题目相关，本题为收集词频
	// 所以每个节点记录词频
	public static int[] times = new int[MAXS];

	// 可以用作队列或者栈，一个容器而已
	public static int[] box = new int[MAXS];

	// 链式前向星，为了建立fail指针的反图
	public static int[] head = new int[MAXS];

	public static int[] next = new int[MAXS];

	public static int[] to = new int[MAXS];

	public static int edge = 0;

	// 遍历fail反图，递归方法会爆栈，所以用非递归替代
	public static boolean[] visited = new boolean[MAXS];

	// AC自动机加入目标字符串
	public static void insert(int i, String str) {
		char[] s = str.toCharArray();
		int u = 0;
		for (int j = 0, c; j < s.length; j++) {
			c = s[j] - 'a';
			if (tree[u][c] == 0) {
				tree[u][c] = ++cnt;
			}
			u = tree[u][c];
		}
		// 每个目标字符串的结尾节点编号
		end[i] = u;
	}

	// 加入所有目标字符串之后
	// 设置fail指针 以及 设置直接直通表
	// 做了AC自动机固定的优化
	public static void setFail() {
		// box当做队列来使用
		int l = 0;
		int r = 0;
		for (int i = 0; i <= 25; i++) {
			if (tree[0][i] > 0) {
				box[r++] = tree[0][i];
			}
		}
		while (l < r) {
			int u = box[l++];
			for (int i = 0; i <= 25; i++) {
				if (tree[u][i] == 0) {
					tree[u][i] = tree[fail[u]][i];
				} else {
					fail[tree[u][i]] = tree[fail[u]][i];
					box[r++] = tree[u][i];
				}
			}
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		int n = Integer.valueOf(in.readLine());
		// AC自动机建树
		for (int i = 1; i <= n; i++) {
			insert(i, in.readLine());
		}
		setFail();
		// 读入大文章
		char[] s = in.readLine().toCharArray();
		for (int u = 0, i = 0; i < s.length; i++) {
			u = tree[u][s[i] - 'a'];
			// 增加匹配次数
			times[u]++;
		}
		for (int i = 1; i <= cnt; i++) {
			// 根据fail指针建反图
			// 其实是一颗树
			addEdge(fail[i], i);
		}
		// 遍历fail指针建的树
		// 汇总每个节点的词频
		f2(0);
		for (int i = 1; i <= n; i++) {
			out.println(times[end[i]]);
		}
		out.flush();
		out.close();
		in.close();
	}

	public static void addEdge(int u, int v) {
		next[++edge] = head[u];
		head[u] = edge;
		to[edge] = v;
	}

	// 逻辑是对的
	// 但是递归开太多层了会爆栈
	// C++这道题不会爆栈
	// java会
	public static void f1(int u) {
		for (int i = head[u]; i > 0; i = next[i]) {
			f1(to[i]);
			times[u] += times[to[i]];
		}
	}

	// 改成非递归才能通过
	// 因为是用栈来模拟递归
	// 只消耗内存空间(box和visited)
	// 不消耗系统栈的空间
	// 所以很安全
	public static void f2(int u) {
		// box当做栈来使用
		int r = 0;
		box[r++] = u;
		int cur;
		while (r > 0) {
			cur = box[r - 1];
			if (!visited[cur]) {
				visited[cur] = true;
				for (int i = head[cur]; i > 0; i = next[i]) {
					box[r++] = to[i];
				}
			} else {
				r--;
				for (int i = head[cur]; i > 0; i = next[i]) {
					times[cur] += times[to[i]];
				}
			}
		}
	}

}

package class103;

// Manacher算法模版
// 求字符串s中最长回文子串的长度
// 测试链接 : https://www.luogu.com.cn/problem/P3805
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code01_Manacher {

	public static int MAXN = 11000001;

	public static char[] ss = new char[MAXN << 1];

	public static int[] p = new int[MAXN << 1];

	public static int n;

	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		out.println(manacher(in.readLine()));
		out.flush();
		out.close();
		in.close();
	}

	public static int manacher(String str) {
		manacherss(str.toCharArray());
		int max = 0;
		for (int i = 0, c = 0, r = 0, len; i < n; i++) {
			len = r > i ? Math.min(p[2 * c - i], r - i) : 1;
			while (i + len < n && i - len >= 0 && ss[i + len] == ss[i - len]) {
				len++;
			}
			if (i + len > r) {
				r = i + len;
				c = i;
			}
			max = Math.max(max, len);
			p[i] = len;
		}
		return max - 1;
	}

	public static void manacherss(char[] a) {
		n = a.length * 2 + 1;
		for (int i = 0, j = 0; i < n; i++) {
			ss[i] = (i & 1) == 0 ? '#' : a[j++];
		}
	}

}

package class103;

// 扩展KMP模版，又称Z算法或Z函数
// 给定两个字符串a、b，求出两个数组
// b与b每一个后缀串的最长公共前缀长度，z数组
// b与a每一个后缀串的最长公共前缀长度，e数组
// 计算出要求的两个数组后，输出这两个数组的权值即可
// 对于一个数组x，i位置的权值定义为 : (i * (x[i] + 1))
// 数组权值为所有位置权值的异或和
// 测试链接 : https://www.luogu.com.cn/problem/P5410
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code02_ExpandKMP {

	public static int MAXN = 20000001;

	public static int[] z = new int[MAXN];

	public static int[] e = new int[MAXN];

	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		char[] a = in.readLine().toCharArray();
		char[] b = in.readLine().toCharArray();
		zArray(b, b.length);
		eArray(a, b, a.length, b.length);
		out.println(eor(z, b.length));
		out.println(eor(e, a.length));
		out.flush();
		out.close();
		in.close();
	}

	// 非常像Manacher算法
	public static void zArray(char[] s, int n) {
		z[0] = n;
		for (int i = 1, c = 1, r = 1, len; i < n; i++) {
			len = r > i ? Math.min(r - i, z[i - c]) : 0;
			while (i + len < n && s[i + len] == s[len]) {
				len++;
			}
			if (i + len > r) {
				r = i + len;
				c = i;
			}
			z[i] = len;
		}
	}

	// 非常像Manacher算法
	public static void eArray(char[] a, char[] b, int n, int m) {
		for (int i = 0, c = 0, r = 0, len; i < n; i++) {
			len = r > i ? Math.min(r - i, z[i - c]) : 0;
			while (i + len < n && len < m && a[i + len] == b[len]) {
				len++;
			}
			if (i + len > r) {
				r = i + len;
				c = i;
			}
			e[i] = len;
		}
	}

	public static long eor(int[] arr, int n) {
		long ans = 0;
		for (int i = 0; i < n; i++) {
			ans ^= (long) (i + 1) * (arr[i] + 1);
		}
		return ans;
	}

}

package class121;

// 树的直径模版(两遍dfs)
// 给定一棵树，边权可能为负，求直径长度
// 测试链接 : https://www.luogu.com.cn/problem/U81904
// 提交以下的code，提交时请把类名改成"Main"
// 会有无法通过的用例，因为树上有负边

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Code01_Diameter1 {

	public static int MAXN = 500001;

	public static int n;

	public static int[] head = new int[MAXN];

	public static int[] next = new int[MAXN << 1];

	public static int[] to = new int[MAXN << 1];

	public static int[] weight = new int[MAXN << 1];

	public static int cnt;

	// 直径的开始点
	public static int start;

	// 直径的结束点
	public static int end;

	// 直径长度
	public static int diameter;

	// dist[i] : 从规定的头节点出发，走到i的距离
	public static int[] dist = new int[MAXN];

	// last[i] : 从规定的头节点出发，i节点的上一个节点
	public static int[] last = new int[MAXN];

	public static void build() {
		cnt = 1;
		Arrays.fill(head, 1, n + 1, 0);
	}

	public static void addEdge(int u, int v, int w) {
		next[cnt] = head[u];
		to[cnt] = v;
		weight[cnt] = w;
		head[u] = cnt++;
	}

	public static void road() {
		dfs(1, 0, 0);
		start = 1;
		for (int i = 2; i <= n; i++) {
			if (dist[i] > dist[start]) {
				start = i;
			}
		}
		dfs(start, 0, 0);
		end = 1;
		for (int i = 2; i <= n; i++) {
			if (dist[i] > dist[end]) {
				end = i;
			}
		}
		diameter = dist[end];
	}

	public static void dfs(int u, int f, int w) {
		last[u] = f;
		dist[u] = dist[f] + w;
		for (int e = head[u]; e != 0; e = next[e]) {
			if (to[e] != f) {
				dfs(to[e], u, weight[e]);
			}
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		build();
		for (int i = 1, u, v, w; i < n; i++) {
			in.nextToken();
			u = (int) in.nval;
			in.nextToken();
			v = (int) in.nval;
			in.nextToken();
			w = (int) in.nval;
			addEdge(u, v, w);
			addEdge(v, u, w);
		}
		road();
		out.println(diameter);
		out.flush();
		out.close();
		br.close();
	}

}

package class121;

// 树的直径模版(树型dp)
// 给定一棵树，边权可能为负，求直径长度
// 测试链接 : https://www.luogu.com.cn/problem/U81904
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有的用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Code01_Diameter2 {

	public static int MAXN = 500001;

	public static int n;

	public static int[] head = new int[MAXN];

	public static int[] next = new int[MAXN << 1];

	public static int[] to = new int[MAXN << 1];

	public static int[] weight = new int[MAXN << 1];

	public static int cnt;

	// dist[u] : 从u开始必须往下走，能走出的最大距离，可以不选任何边
	public static int[] dist = new int[MAXN];

	// ans[u] : 路径必须包含点u的情况下，最大路径和
	public static int[] ans = new int[MAXN];

	public static void build() {
		cnt = 1;
		Arrays.fill(head, 1, n + 1, 0);
		Arrays.fill(dist, 1, n + 1, 0);
		Arrays.fill(ans, 1, n + 1, 0);
	}

	public static void addEdge(int u, int v, int w) {
		next[cnt] = head[u];
		to[cnt] = v;
		weight[cnt] = w;
		head[u] = cnt++;
	}

	public static void dp(int u, int f) {
		for (int e = head[u], v; e != 0; e = next[e]) {
			v = to[e];
			if (v != f) {
				dp(v, u);
			}
		}
		for (int e = head[u], v; e != 0; e = next[e]) {
			v = to[e];
			if (v != f) {
				ans[u] = Math.max(ans[u], dist[u] + dist[v] + weight[e]);
				dist[u] = Math.max(dist[u], dist[v] + weight[e]);
			}
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		build();
		for (int i = 1, u, v, w; i < n; i++) {
			in.nextToken();
			u = (int) in.nval;
			in.nextToken();
			v = (int) in.nval;
			in.nextToken();
			w = (int) in.nval;
			addEdge(u, v, w);
			addEdge(v, u, w);
		}
		dp(1, 0);
		int diameter = Integer.MIN_VALUE;
		for (int i = 1; i <= n; i++) {
			diameter = Math.max(diameter, ans[i]);
		}
		out.println(diameter);
		out.flush();
		out.close();
		br.close();
	}

}

package class133;

// 高斯消元解决加法方程组模版(区分矛盾、多解、唯一解)
// 一共有n个变量，给定n个加法方程，构成一个加法方程组
// 如果方程组存在矛盾，打印-1
// 如果方程组无法确定唯一解，打印0
// 如果方程组存在唯一解，打印每个变量的值，保留小数点后两位
// 1 <= n <= 50
// 测试链接 : https://www.luogu.com.cn/problem/P2455
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code02_GaussAdd {

	public static int MAXN = 52;

	public static double[][] mat = new double[MAXN][MAXN];

	public static int n;

	// 0.0000001 == 1e-7
	// 因为double类型有精度问题，所以认为
	// 如果一个数字绝对值 <  sml，则认为该数字是0
	// 如果一个数字绝对值 >= sml，则认为该数字不是0
	public static double sml = 1e-7;

	// 高斯消元解决加法方程组模版
	// 需要保证变量有n个，表达式也有n个
	public static void gauss(int n) {
		for (int i = 1; i <= n; i++) {
			// 本题需要严格区分矛盾、多解、唯一解，所以必须这么写
			int max = i;
			for (int j = 1; j <= n; j++) {
				if (j < i && Math.abs(mat[j][j]) >= sml) {
					continue;
				}
				if (Math.abs(mat[j][i]) > Math.abs(mat[max][i])) {
					max = j;
				}
			}
			swap(i, max);
			if (Math.abs(mat[i][i]) >= sml) {
				double tmp = mat[i][i];
				for (int j = i; j <= n + 1; j++) {
					mat[i][j] /= tmp;
				}
				for (int j = 1; j <= n; j++) {
					if (i != j) {
						double rate = mat[j][i] / mat[i][i];
						for (int k = i; k <= n + 1; k++) {
							mat[j][k] -= mat[i][k] * rate;
						}
					}
				}
			}
		}
	}

	public static void swap(int a, int b) {
		double[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n + 1; j++) {
				in.nextToken();
				mat[i][j] = (double) in.nval;
			}
		}
		gauss(n);
		int sign = 1;
		for (int i = 1; i <= n; i++) {
			if (Math.abs(mat[i][i]) < sml && Math.abs(mat[i][n + 1]) >= sml) {
				sign = -1;
				break;
			}
			if (Math.abs(mat[i][i]) < sml) {
				sign = 0;
			}
		}
		if (sign == 1) {
			for (int i = 1; i <= n; i++) {
				out.printf("x" + i + "=" + "%.2f\n", mat[i][n + 1]);
			}
		} else {
			out.println(sign);
		}
		out.flush();
		out.close();
		br.close();
	}

}

package class136;

// 最大异或和
// 给定一个长度为n的数组arr，arr中都是long类型的非负数，可能有重复值
// 在这些数中选取任意个，使得异或和最大，返回最大的异或和
// 1 <= n <= 50
// 0 <= arr[i] <= 2^50
// 测试链接 : https://www.luogu.com.cn/problem/P3812
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code01_MaximumXor {

	public static int MAXN = 51;

	public static int BIT = 50;

	public static long[] arr = new long[MAXN];

	public static long[] basis = new long[BIT + 1];

	public static int n;

	// 普通消元
	// 计算最大异或和
	public static long compute() {
		for (int i = 1; i <= n; i++) {
			insert(arr[i]);
		}
		long ans = 0;
		for (int i = BIT; i >= 0; i--) {
			ans = Math.max(ans, ans ^ basis[i]);
		}
		return ans;
	}

	// 线性基里插入num，如果线性基增加了返回true，否则返回false
	public static boolean insert(long num) {
		for (int i = BIT; i >= 0; i--) {
			if (num >> i == 1) {
				if (basis[i] == 0) {
					basis[i] = num;
					return true;
				}
				num ^= basis[i];
			}
		}
		return false;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		for (int i = 1; i <= n; i++) {
			in.nextToken();
			arr[i] = (long) in.nval;
		}
		compute();
		out.println(compute());
		out.flush();
		out.close();
		br.close();
	}

}

package class140;

// 二元一次不定方程模版
// 给定a、b、c，求解方程ax + by = c
// 如果方程无解打印-1
// 如果方程无正整数解，但是有整数解
// 打印这些整数解中，x的最小正数值，y的最小正数值
// 如果方程有正整数解，打印正整数解的数量，同时打印所有正整数解中，
// x的最小正数值，y的最小正数值，x的最大正数值，y的最大正数值
// 1 <= a、b、c <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/P5656
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <iostream>
//#include <cstdio>
//
//using namespace std;
//
//long long d, x, y, px, py;
//
//void exgcd(long long a, long long b) {
//    if (b == 0) {
//        d = a;
//        x = 1;
//        y = 0;
//    } else {
//        exgcd(b, a % b);
//        px = x;
//        py = y;
//        x = py;
//        y = px - py * (a / b);
//    }
//}
//
//long long a, b, c, xd, yd, times;
//
//int main() {
//    int cases;
//    scanf("%d", &cases);
//    for (int t = 1; t <= cases; t++) {
//        scanf("%lld %lld %lld", &a, &b, &c);
//        exgcd(a, b);
//        if (c % d != 0) {
//            printf("-1\n");
//        } else {
//            x *= c / d;
//            y *= c / d;
//            xd = b / d;
//            yd = a / d;
//            if (x < 0) {
//                times = (xd - x) / xd;
//                x += xd * times;
//                y -= yd * times;
//            } else {
//                times = (x - 1) / xd;
//                x -= xd * times;
//                y += yd * times;
//            }
//            if (y <= 0) {
//                printf("%lld ", x);
//                printf("%lld\n", y + yd * ((yd - y) / yd));
//            } else {
//                printf("%lld ", ((y - 1) / yd + 1));
//                printf("%lld ", x);
//                printf("%lld ", (y - (y - 1) / yd * yd));
//                printf("%lld ", (x + (y - 1) / yd * xd));
//                printf("%lld\n", y);
//            }
//        }
//    }
//    return 0;
//}


package class141;

// 中国剩余定理模版
// 给出n个同余方程，求满足同余方程的最小正数解x
// 一共n个同余方程，x ≡ ri(% mi)
// 1 <= n <= 10
// 0 <= ri、mi <= 10^5
// 所有mi一定互质
// 所有mi整体乘积 <= 10^18
// 测试链接 : https://www.luogu.com.cn/problem/P1495
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code01_CRT {

	public static int MAXN = 11;

	public static long m[] = new long[MAXN];

	public static long r[] = new long[MAXN];

	// 中国剩余定理模版
	public static long crt(int n) {
		long lcm = 1;
		for (int i = 1; i <= n; i++) {
			lcm = lcm * m[i];
		}
		long ai, ci, ans = 0;
		for (int i = 1; i <= n; i++) {
			// ai = lcm / m[i]
			ai = lcm / m[i];
			// ai逆元，在%m[i]意义下的逆元
			exgcd(ai, m[i]);
			// ci = (ri * ai * ai逆元) % lcm
			ci = multiply(r[i], multiply(ai, x, lcm), lcm);
			ans = (ans + ci) % lcm;
		}
		return ans;
	}

	// 讲解139 - 扩展欧几里得算法
	public static long d, x, y, px, py;

	public static void exgcd(long a, long b) {
		if (b == 0) {
			d = a;
			x = 1;
			y = 0;
		} else {
			exgcd(b, a % b);
			px = x;
			py = y;
			x = py;
			y = px - py * (a / b);
		}
	}

	// 讲解033 - 位运算实现乘法
	// a*b过程每一步都%mod，这么写是防止溢出，也叫龟速乘
	public static long multiply(long a, long b, long mod) {
		a = (a % mod + mod) % mod;
		b = (b % mod + mod) % mod;
		long ans = 0;
		while (b != 0) {
			if ((b & 1) != 0) {
				ans = (ans + a) % mod;
			}
			a = (a + a) % mod;
			b >>= 1;
		}
		return ans;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		int n = (int) in.nval;
		for (int i = 1; i <= n; i++) {
			in.nextToken();
			m[i] = (long) in.nval;
			in.nextToken();
			r[i] = (long) in.nval;
		}
		out.println(crt(n));
		out.flush();
		out.close();
		br.close();
	}

}


package class141;

// 扩展中国剩余定理模版
// 给出n个同余方程，求满足同余方程的最小正数解x
// 一共n个同余方程，x ≡ ri(% mi)
// 1 <= n <= 10^5
// 0 <= ri、mi <= 10^12
// 所有mi不一定互质
// 所有mi的最小公倍数 <= 10^18
// 测试链接 : https://www.luogu.com.cn/problem/P4777
// 测试链接 : https://www.luogu.com.cn/problem/P1495
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code02_EXCRT {

	public static int MAXN = 100001;

	public static long m[] = new long[MAXN];

	public static long r[] = new long[MAXN];

	// 扩展中国剩余定理模版
	public static long excrt(int n) {
		long tail = 0, lcm = 1, tmp, b, c, x0;
		// ans = lcm * x + tail
		for (int i = 1; i <= n; i++) {
			// ans = m[i] * y + ri
			// lcm * x + m[i] * y = ri - tail
			// a = lcm
			// b = m[i]
			// c = ri - tail
			b = m[i];
			c = ((r[i] - tail) % b + b) % b;
			exgcd(lcm, b);
			if (c % d != 0) {
				return -1;
			}
			// ax + by = gcd(a,b)，特解是，x变量
			// ax + by = c，特解是，x变量 * (c/d)
			// ax + by = c，最小非负特解x0 = (x * (c/d)) % (b/d) 取非负余数
			// 通解 = x0 + (b/d) * n
			x0 = multiply(x, c / d, b / d);
			// ans = lcm * x + tail，带入通解
			// ans = lcm * (x0 + (b/d) * n) + tail
			// ans = lcm * (b/d) * n + lcm * x0 + tail
			// tail' = tail' % lcm'
			tmp = lcm * (b / d);
			tail = (tail + multiply(x0, lcm, tmp)) % tmp;
			lcm = tmp;
		}
		return tail;
	}

	// 讲解139 - 扩展欧几里得算法
	public static long d, x, y, px, py;

	public static void exgcd(long a, long b) {
		if (b == 0) {
			d = a;
			x = 1;
			y = 0;
		} else {
			exgcd(b, a % b);
			px = x;
			py = y;
			x = py;
			y = px - py * (a / b);
		}
	}

	// 讲解033 - 位运算实现乘法
	// a*b过程每一步都%mod，这么写是防止溢出，也叫龟速乘
	public static long multiply(long a, long b, long mod) {
		a = (a % mod + mod) % mod;
		b = (b % mod + mod) % mod;
		long ans = 0;
		while (b != 0) {
			if ((b & 1) != 0) {
				ans = (ans + a) % mod;
			}
			a = (a + a) % mod;
			b >>= 1;
		}
		return ans;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		int n = (int) in.nval;
		for (int i = 1; i <= n; i++) {
			in.nextToken();
			m[i] = (long) in.nval;
			in.nextToken();
			r[i] = (long) in.nval;
		}
		out.println(excrt(n));
		out.flush();
		out.close();
		br.close();
	}

}

package class142;

// 负环和差分约束模版题(转化成形式2进而转化成判断无限增加的环)
// 一共有n个变量，编号1~n，给定m个不等式，每个不等式的形式为
// Xi - Xj <= Ci，其中Xi和Xj为变量，Ci为常量
// 如果不等式存在矛盾导致无解，打印"NO"
// 如果有解，打印满足所有不等式的其中一组解(X1, X2...)
// 1 <= n、m <= 5 * 10^3
// -10^4 <= Ci <= +10^4 
// 测试链接 : https://www.luogu.com.cn/problem/P5960
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Code01_DifferenceConstraints2 {

	public static int MAXN = 5001;

	public static int MAXM = 10001;

	// 链式前向星需要
	public static int[] head = new int[MAXN];

	public static int[] next = new int[MAXM];

	public static int[] to = new int[MAXM];

	public static int[] weight = new int[MAXM];

	public static int cnt;

	// spfa需要
	public static int[] dist = new int[MAXN];

	public static int[] update = new int[MAXN];

	public static int MAXQ = 5000001;

	public static int[] queue = new int[MAXQ];

	public static int h, t;

	public static boolean[] enter = new boolean[MAXN];

	public static int n, m;

	public static void prepare() {
		cnt = 1;
		h = t = 0;
		Arrays.fill(head, 0, n + 1, 0);
		// 所有距离先设置成最小值
		Arrays.fill(dist, 0, n + 1, Integer.MIN_VALUE);
		Arrays.fill(update, 0, n + 1, 0);
		Arrays.fill(enter, 0, n + 1, false);
	}

	public static void addEdge(int u, int v, int w) {
		next[cnt] = head[u];
		to[cnt] = v;
		weight[cnt] = w;
		head[u] = cnt++;
	}

	// 来自讲解065，spfa判断无限增加环，s是超级源点
	public static boolean spfa(int s) {
		dist[s] = 0;
		update[s] = 1;
		queue[t++] = s;
		enter[s] = true;
		while (h < t) {
			int u = queue[h++];
			enter[u] = false;
			for (int ei = head[u], v, w; ei > 0; ei = next[ei]) {
				v = to[ei];
				w = weight[ei];
				if (dist[v] < dist[u] + w) { // 变大才更新
					dist[v] = dist[u] + w;
					if (!enter[v]) {
						// 注意判断逻辑和讲解065的代码不一样
						// 因为节点0是额外增加的超级源点
						// 所以节点数量增加了1个，所以这么判断
						if (++update[v] > n) {
							return true;
						}
						queue[t++] = v;
						enter[v] = true;
					}
				}
			}
		}
		return false;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken(); n = (int) in.nval;
		in.nextToken(); m = (int) in.nval;
		prepare();
		// 0号点是连通超级源点，保证图的连通性
		for (int i = 1; i <= n; i++) {
			addEdge(0, i, 0);
		}
		for (int i = 1, u, v, w; i <= m; i++) {
			in.nextToken(); u = (int) in.nval;
			in.nextToken(); v = (int) in.nval;
			in.nextToken(); w = (int) in.nval;
			// 形式2的连边方式
			addEdge(u, v, -w);
		}
		if (spfa(0)) {
			out.println("NO");
		} else {
			for (int i = 1; i <= n; i++) {
				out.print(dist[i] + " ");
			}
			out.println();
		}
		out.flush();
		out.close();
		br.close();
	}

}
package class142;

// 倍杀测量者
// 如果 A的分数 >= B的分数 * k，k是正实数，就称 A k倍杀 B，或称 B被A k倍杀了
// 一场比赛中，一共有n个选手，有m1条誓言记录，有m2条选手得分记录，得分只可能是正实数
// 类型1的誓言 u v k : 选手u 没有k倍杀 选手v，那么选手u就穿女装
// 类型2的誓言 u v k : 选手u 被选手v k倍杀了，那么选手u就穿女装
// 选手的得分    u w : 选手u得了w分，如果某选手没有得分记录，按照尽量不穿女装的情况推测
// 你希望看到比赛后有人穿女装，但不想看到很多人穿女装，于是想制定正实数ans，效果如下
// 类型1的誓言，比例调整成(k-ans)，类型2的誓言，比例调整成(k+ans)，即提高了穿女装的条件
// 计算ans最大多少，依然有人穿女装，保留小数点后4位，如果不干预也没人穿女装，返回-1
// 1 <= n, m1, m2 <= 1000
// 1 <= k <= 10
// 1 <= w <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/P4926
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Code04_Measurer1 {

	public static int MAXN = 1002;

	public static int MAXM = 3001;

	public static double INF = 1e10;

	public static double sml = 1e-6;

	public static int n, m1, m2;

	// 誓言记录(誓言类型, u, v, k)
	public static int[][] vow = new int[MAXN][4];

	// 得分记录(u, w)
	public static int[][] score = new int[MAXN][2];

	// 链式前向星需要
	public static int[] head = new int[MAXN];

	public static int[] next = new int[MAXM];

	public static int[] to = new int[MAXM];

	public static double[] weight = new double[MAXM];

	public static int cnt;

	// spfa需要
	public static double[] dist = new double[MAXN];

	public static int[] update = new int[MAXN];

	public static int MAXQ = 1000001;

	public static int[] queue = new int[MAXQ];

	public static int h, t;

	public static boolean[] enter = new boolean[MAXN];

	public static void prepare() {
		cnt = 1;
		h = t = 0;
		Arrays.fill(head, 0, n + 2, 0);
		Arrays.fill(dist, 0, n + 2, INF);
		Arrays.fill(update, 0, n + 2, 0);
		Arrays.fill(enter, 0, n + 2, false);
	}

	public static void addEdge(int u, int v, double w) {
		next[cnt] = head[u];
		to[cnt] = v;
		weight[cnt] = w;
		head[u] = cnt++;
	}

	public static double compute() {
		double l = 0, r = INF, m, ans = 0;
		while (r - l >= sml) {
			m = (l + r) / 2;
			if (check(m)) {
				ans = m;
				l = m + sml;
			} else {
				r = m - sml;
			}
		}
		return ans;
	}

	// 是否有人穿女装
	public static boolean check(double limit) {
		prepare();
		// 0号点是连通超级源点，保证图的连通
		for (int i = 1; i <= n; i++) {
			addEdge(0, i, 0);
		}
		// 倍杀关系的建边
		for (int i = 1; i <= m1; i++) {
			if (vow[i][0] == 1) {
				// 课上的代码没有这个判断，加上才是正确的，防止log里出现负数
				if (-limit + vow[i][3] >= 0) {
					addEdge(vow[i][1], vow[i][2], -Math.log(-limit + vow[i][3]));
				}
			} else {
				// 因为类型2的誓言是<关系，所以减去最小精度后，就可以认为是<=关系
				addEdge(vow[i][1], vow[i][2], Math.log(limit + vow[i][3] - sml));
			}
		}
		// n+1号点是限制超级源点，保证确定得分的选手之间的关系
		// 本题测试数据有限，两个超级源点合并居然也能通过
		// 原理上两个超级源点一定要分开，课上进行了重点讲解
		for (int i = 1; i <= m2; i++) {
			addEdge(n + 1, score[i][0], Math.log(score[i][1]));
			addEdge(score[i][0], n + 1, -Math.log(score[i][1]));
		}
		return spfa(0);
	}

	public static boolean spfa(int s) {
		dist[s] = 0;
		update[s] = 1;
		queue[t++] = s;
		enter[s] = true;
		while (h < t) {
			int u = queue[h++];
			enter[u] = false;
			for (int ei = head[u]; ei > 0; ei = next[ei]) {
				int v = to[ei];
				double w = weight[ei];
				if (dist[v] > dist[u] + w) {
					dist[v] = dist[u] + w;
					if (!enter[v]) {
						// 0...n+1号点，一共n+2个点，所以这里判断 > n + 1
						if (++update[v] > n + 1) {
							return true;
						}
						queue[t++] = v;
						enter[v] = true;
					}
				}
			}
		}
		return false;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		in.nextToken();
		m1 = (int) in.nval;
		in.nextToken();
		m2 = (int) in.nval;
		for (int i = 1; i <= m1; i++) {
			in.nextToken();
			vow[i][0] = (int) in.nval;
			in.nextToken();
			vow[i][1] = (int) in.nval;
			in.nextToken();
			vow[i][2] = (int) in.nval;
			in.nextToken();
			vow[i][3] = (int) in.nval;
		}
		for (int i = 1; i <= m2; i++) {
			in.nextToken();
			score[i][0] = (int) in.nval;
			in.nextToken();
			score[i][1] = (int) in.nval;
		}
		double ans = compute();
		if (ans == 0) {
			out.println("-1");
		} else {
			out.println(ans);
		}
		out.flush();
		out.close();
		br.close();
	}

}

package class143;

// 跳楼机
// 一座大楼一共有h层，楼层编号1~h，有如下四种移动方式
// 1, 向上移动x层
// 2, 向上移动y层
// 3, 向上移动z层
// 4, 回到1层
// 假设你正在第1层，请问大楼里有多少楼层你可以到达
// 1 <= h <= 2^63 - 1
// 1 <= x、y、z <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P3403
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Code01_Elevator {

	public static int MAXN = 100001;

	public static int MAXM = 200001;

	public static long h;

	public static int x, y, z;

	// 链式前向星需要
	public static int[] head = new int[MAXN];

	public static int[] next = new int[MAXM];

	public static int[] to = new int[MAXM];

	public static long[] weight = new long[MAXM];

	public static int cnt;

	// dijkstra算法需要
	// 0 : 当前节点
	// 1 : 源点到当前点距离
	public static PriorityQueue<long[]> heap = new PriorityQueue<>((a, b) -> a[1] <= b[1] ? -1 : 1);

	public static long[] distance = new long[MAXN];

	public static boolean[] visited = new boolean[MAXN];

	public static void prepare() {
		cnt = 1;
		heap.clear();
		Arrays.fill(head, 0, x, 0);
		Arrays.fill(distance, 0, x, Long.MAX_VALUE);
		Arrays.fill(visited, 0, x, false);
	}

	public static void addEdge(int u, int v, long w) {
		next[cnt] = head[u];
		to[cnt] = v;
		weight[cnt] = w;
		head[u] = cnt++;
	}

	// 来自讲解064，dijkstra算法
	public static void dijkstra() {
		heap.add(new long[] { 0, 0 });
		distance[0] = 0;
		long[] cur;
		int u;
		long w;
		while (!heap.isEmpty()) {
			cur = heap.poll();
			u = (int) cur[0];
			w = cur[1];
			if (visited[u]) {
				continue;
			}
			visited[u] = true;
			for (int ei = head[u], v; ei > 0; ei = next[ei]) {
				v = to[ei];
				if (!visited[v] && distance[v] > w + weight[ei]) {
					distance[v] = w + weight[ei];
					heap.add(new long[] { v, distance[v] });
				}
			}
		}
	}

	public static long compute() {
		dijkstra();
		long ans = 0;
		for (int i = 0; i < x; i++) {
			if (distance[i] <= h) {
				ans += (h - distance[i]) / x + 1;
			}
		}
		return ans;
	}

	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		h = io.nextLong() - 1;
		x = io.nextInt();
		y = io.nextInt();
		z = io.nextInt();
		prepare();
		for (int i = 0; i < x; i++) {
			addEdge(i, (i + y) % x, y);
			addEdge(i, (i + z) % x, z);
		}
		io.println(compute());
		io.flush();
		io.close();
	}

	// Kattio类IO效率很好，但还是不如StreamTokenizer
	// 只有StreamTokenizer无法正确处理时，才考虑使用这个类
	// 参考链接 : https://oi-wiki.org/lang/java-pro/
	public static class Kattio extends PrintWriter {
		private BufferedReader r;
		private StringTokenizer st;

		public Kattio() {
			this(System.in, System.out);
		}

		public Kattio(InputStream i, OutputStream o) {
			super(o);
			r = new BufferedReader(new InputStreamReader(i));
		}

		public Kattio(String intput, String output) throws IOException {
			super(output);
			r = new BufferedReader(new FileReader(intput));
		}

		public String next() {
			try {
				while (st == null || !st.hasMoreTokens())
					st = new StringTokenizer(r.readLine());
				return st.nextToken();
			} catch (Exception e) {
			}
			return null;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}
	}

}

package class143;

// 墨墨的等式(两次转圈法)
// 一共有n种正数，每种数可以选择任意个，个数不能是负数
// 那么一定有某些数值可以由这些数字累加得到
// 请问在[l...r]范围上，有多少个数能被累加得到
// 0 <= n <= 12
// 0 <= 数值范围 <= 5 * 10^5
// 1 <= l <= r <= 10^12
// 测试链接 : https://www.luogu.com.cn/problem/P2371
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Code04_MomoEquation2 {

	public static int MAXN = 500001;

	public static long inf = Long.MAX_VALUE;

	public static int[] v = new int[MAXN];

	public static long[] dist = new long[MAXN];

	public static int n, x;

	public static long l, r;

	public static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}

	public static long compute() {
		Arrays.sort(v, 1, n + 1);
		int size = 0;
		for (int i = 1; i <= n; i++) {
			if (v[i] != 0) {
				v[++size] = v[i];
			}
		}
		if (size == 0) {
			return 0;
		}
		x = v[1];
		Arrays.fill(dist, 0, x, inf);
		dist[0] = 0;
		for (int i = 2, d; i <= size; i++) { // 出现基准数之外的其他数，更新最短路
			d = gcd(v[i], x); // 求最大公约数
			for (int j = 0; j < d; j++) { // j是每个子环的起点
				for (int cur = j, next, circle = 0; circle < 2; circle += cur == j ? 1 : 0) {
					next = (cur + v[i]) % x;
					if (dist[cur] != inf) {
						dist[next] = Math.min(dist[next], dist[cur] + v[i]);
					}
					cur = next;
				}
			}
		}
		long ans = 0;
		for (int i = 0; i < x; i++) {
			if (r >= dist[i]) {
				ans += Math.max(0, (r - dist[i]) / x + 1);
			}
			if (l >= dist[i]) {
				ans -= Math.max(0, (l - dist[i]) / x + 1);
			}
		}
		return ans;
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		in.nextToken();
		l = (long) in.nval - 1;
		in.nextToken();
		r = (long) in.nval;
		for (int i = 1; i <= n; i++) {
			in.nextToken();
			v[i] = (int) in.nval;
		}
		out.println(compute());
		out.flush();
		out.close();
		br.close();
	}

}

package class148;

// AVL树的实现(C++版)
// 实现一种结构，支持如下操作，要求单次调用的时间复杂度O(log n)
// 1，增加x，重复加入算多个词频
// 2，删除x，如果有多个，只删掉一个
// 3，查询x的排名，x的排名为，比x小的数的个数+1
// 4，查询数据中排名为x的数
// 5，查询x的前驱，x的前驱为，小于x的数中最大的数，不存在返回整数最小值
// 6，查询x的后继，x的后继为，大于x的数中最小的数，不存在返回整数最大值
// 所有操作的次数 <= 10^5
// -10^7 <= x <= +10^7
// 测试链接 : https://www.luogu.com.cn/problem/P3369
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <iostream>
//#include <algorithm>
//#include <climits>
//#include <cstring>
//
//using namespace std;
//
//const int MAXN = 100001;
//
//int cnt = 0;
//int head = 0;
//int key[MAXN];
//int height[MAXN];
//int ls[MAXN];
//int rs[MAXN];
//int key_count[MAXN];
//int siz[MAXN];
//
//void up(int i) {
//    siz[i] = siz[ls[i]] + siz[rs[i]] + key_count[i];
//    height[i] = max(height[ls[i]], height[rs[i]]) + 1;
//}
//
//int leftRotate(int i) {
//    int r = rs[i];
//    rs[i] = ls[r];
//    ls[r] = i;
//    up(i);
//    up(r);
//    return r;
//}
//
//int rightRotate(int i) {
//    int l = ls[i];
//    ls[i] = rs[l];
//    rs[l] = i;
//    up(i);
//    up(l);
//    return l;
//}
//
//int maintain(int i) {
//    int lh = height[ls[i]];
//    int rh = height[rs[i]];
//    if (lh - rh > 1) {
//        if (height[ls[ls[i]]] >= height[rs[ls[i]]]) {
//            i = rightRotate(i);
//        } else {
//            ls[i] = leftRotate(ls[i]);
//            i = rightRotate(i);
//        }
//    } else if (rh - lh > 1) {
//        if (height[rs[rs[i]]] >= height[ls[rs[i]]]) {
//            i = leftRotate(i);
//        } else {
//            rs[i] = rightRotate(rs[i]);
//            i = leftRotate(i);
//        }
//    }
//    return i;
//}
//
//int add(int i, int num) {
//    if (i == 0) {
//        key[++cnt] = num;
//        key_count[cnt] = siz[cnt] = height[cnt] = 1;
//        return cnt;
//    }
//    if (key[i] == num) {
//        key_count[i]++;
//    } else if (key[i] > num) {
//        ls[i] = add(ls[i], num);
//    } else {
//        rs[i] = add(rs[i], num);
//    }
//    up(i);
//    return maintain(i);
//}
//
//void add(int num) {
//    head = add(head, num);
//}
//
//int getRank(int i, int num) {
//    if (i == 0) {
//        return 0;
//    }
//    if (key[i] >= num) {
//        return getRank(ls[i], num);
//    } else {
//        return siz[ls[i]] + key_count[i] + getRank(rs[i], num);
//    }
//}
//
//int getRank(int num) {
//    return getRank(head, num) + 1;
//}
//
//int removeMostLeft(int i, int mostLeft) {
//    if (i == mostLeft) {
//        return rs[i];
//    } else {
//        ls[i] = removeMostLeft(ls[i], mostLeft);
//        up(i);
//        return maintain(i);
//    }
//}
//
//int remove(int i, int num) {
//    if (key[i] < num) {
//        rs[i] = remove(rs[i], num);
//    } else if (key[i] > num) {
//        ls[i] = remove(ls[i], num);
//    } else {
//        if (key_count[i] > 1) {
//            key_count[i]--;
//        } else {
//            if (ls[i] == 0 && rs[i] == 0) {
//                return 0;
//            } else if (ls[i] != 0 && rs[i] == 0) {
//                i = ls[i];
//            } else if (ls[i] == 0 && rs[i] != 0) {
//                i = rs[i];
//            } else {
//                int mostLeft = rs[i];
//                while (ls[mostLeft] != 0) {
//                    mostLeft = ls[mostLeft];
//                }
//                rs[i] = removeMostLeft(rs[i], mostLeft);
//                ls[mostLeft] = ls[i];
//                rs[mostLeft] = rs[i];
//                i = mostLeft;
//            }
//        }
//    }
//    up(i);
//    return maintain(i);
//}
//
//void remove(int num) {
//    if (getRank(num) != getRank(num + 1)) {
//        head = remove(head, num);
//    }
//}
//
//int index(int i, int x) {
//    if (siz[ls[i]] >= x) {
//        return index(ls[i], x);
//    } else if (siz[ls[i]] + key_count[i] < x) {
//        return index(rs[i], x - siz[ls[i]] - key_count[i]);
//    }
//    return key[i];
//}
//
//int index(int x) {
//    return index(head, x);
//}
//
//int pre(int i, int num) {
//    if (i == 0) {
//        return INT_MIN;
//    }
//    if (key[i] >= num) {
//        return pre(ls[i], num);
//    } else {
//        return max(key[i], pre(rs[i], num));
//    }
//}
//
//int pre(int num) {
//    return pre(head, num);
//}
//
//int post(int i, int num) {
//    if (i == 0) {
//        return INT_MAX;
//    }
//    if (key[i] <= num) {
//        return post(rs[i], num);
//    } else {
//        return min(key[i], post(ls[i], num));
//    }
//}
//
//int post(int num) {
//    return post(head, num);
//}
//
//void clear() {
//    memset(key + 1, 0, cnt * sizeof(int));
//    memset(height + 1, 0, cnt * sizeof(int));
//    memset(ls + 1, 0, cnt * sizeof(int));
//    memset(rs + 1, 0, cnt * sizeof(int));
//    memset(key_count + 1, 0, cnt * sizeof(int));
//    memset(siz + 1, 0, cnt * sizeof(int));
//    cnt = 0;
//    head = 0;
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    int n;
//    cin >> n;
//    for (int i = 1, op, x; i <= n; i++) {
//        cin >> op >> x;
//        if (op == 1) {
//            add(x);
//        } else if (op == 2) {
//            remove(x);
//        } else if (op == 3) {
//            cout << getRank(x) << endl;
//        } else if (op == 4) {
//            cout << index(x) << endl;
//        } else if (op == 5) {
//            cout << pre(x) << endl;
//        } else {
//            cout << post(x) << endl;
//        }
//    }
//    clear();
//    return 0;
//}

package class150;

// 替罪羊树的实现(C++版)
// 实现一种结构，支持如下操作，要求单次调用的时间复杂度O(log n)
// 1，增加x，重复加入算多个词频
// 2，删除x，如果有多个，只删掉一个
// 3，查询x的排名，x的排名为，比x小的数的个数+1
// 4，查询数据中排名为x的数
// 5，查询x的前驱，x的前驱为，小于x的数中最大的数，不存在返回整数最小值
// 6，查询x的后继，x的后继为，大于x的数中最小的数，不存在返回整数最大值
// 所有操作的次数 <= 10^5
// -10^7 <= x <= +10^7
// 测试链接 : https://www.luogu.com.cn/problem/P3369
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <iostream>
//#include <vector>
//#include <algorithm>
//#include <cmath>
//#include <climits>
//#include <cstring>
//
//using namespace std;
//
//const double ALPHA = 0.7;
//const int MAXN = 100001;
//int head = 0;
//int cnt = 0;
//int key[MAXN];
//int key_count[MAXN];
//int ls[MAXN];
//int rs[MAXN];
//int siz[MAXN];
//int diff[MAXN];
//int collect[MAXN];
//int ci;
//int top;
//int father;
//int side;
//
//int init(int num) {
//    key[++cnt] = num;
//    ls[cnt] = rs[cnt] = 0;
//    key_count[cnt] = siz[cnt] = diff[cnt] = 1;
//    return cnt;
//}
//
//void up(int i) {
//    siz[i] = siz[ls[i]] + siz[rs[i]] + key_count[i];
//    diff[i] = diff[ls[i]] + diff[rs[i]] + (key_count[i] > 0 ? 1 : 0);
//}
//
//void inorder(int i) {
//    if (i != 0) {
//        inorder(ls[i]);
//        if (key_count[i] > 0) {
//            collect[++ci] = i;
//        }
//        inorder(rs[i]);
//    }
//}
//
//int build(int l, int r) {
//    if (l > r) {
//        return 0;
//    }
//    int m = (l + r) / 2;
//    int h = collect[m];
//    ls[h] = build(l, m - 1);
//    rs[h] = build(m + 1, r);
//    up(h);
//    return h;
//}
//
//void rebuild() {
//    if (top != 0) {
//        ci = 0;
//        inorder(top);
//        if (ci > 0) {
//            if (father == 0) {
//                head = build(1, ci);
//            } else if (side == 1) {
//                ls[father] = build(1, ci);
//            } else {
//                rs[father] = build(1, ci);
//            }
//        }
//    }
//}
//
//bool balance(int i) {
//    return ALPHA * diff[i] >= max(diff[ls[i]], diff[rs[i]]);
//}
//
//void add(int i, int f, int s, int num) {
//    if (i == 0) {
//        if (f == 0) {
//            head = init(num);
//        } else if (s == 1) {
//            ls[f] = init(num);
//        } else {
//            rs[f] = init(num);
//        }
//    } else {
//        if (key[i] == num) {
//            key_count[i]++;
//        } else if (key[i] > num) {
//            add(ls[i], i, 1, num);
//        } else {
//            add(rs[i], i, 2, num);
//        }
//        up(i);
//        if (!balance(i)) {
//            top = i;
//            father = f;
//            side = s;
//        }
//    }
//}
//
//void add(int num) {
//    top = father = side = 0;
//    add(head, 0, 0, num);
//    rebuild();
//}
//
//int small(int i, int num) {
//    if (i == 0) {
//        return 0;
//    }
//    if (key[i] >= num) {
//        return small(ls[i], num);
//    } else {
//        return siz[ls[i]] + key_count[i] + small(rs[i], num);
//    }
//}
//
//int getRank(int num) {
//    return small(head, num) + 1;
//}
//
//int index(int i, int x) {
//    if (siz[ls[i]] >= x) {
//        return index(ls[i], x);
//    } else if (siz[ls[i]] + key_count[i] < x) {
//        return index(rs[i], x - siz[ls[i]] - key_count[i]);
//    }
//    return key[i];
//}
//
//int index(int x) {
//    return index(head, x);
//}
//
//int pre(int num) {
//    int kth = getRank(num);
//    if (kth == 1) {
//        return INT_MIN;
//    } else {
//        return index(kth - 1);
//    }
//}
//
//int post(int num) {
//    int kth = getRank(num + 1);
//    if (kth == siz[head] + 1) {
//        return INT_MAX;
//    } else {
//        return index(kth);
//    }
//}
//
//void remove(int i, int f, int s, int num) {
//    if (key[i] == num) {
//        key_count[i]--;
//    } else if (key[i] > num) {
//        remove(ls[i], i, 1, num);
//    } else {
//        remove(rs[i], i, 2, num);
//    }
//    up(i);
//    if (!balance(i)) {
//        top = i;
//        father = f;
//        side = s;
//    }
//}
//
//void remove(int num) {
//    if (getRank(num) != getRank(num + 1)) {
//        top = father = side = 0;
//        remove(head, 0, 0, num);
//        rebuild();
//    }
//}
//
//void clear() {
//    memset(key, 0, sizeof(key));
//    memset(key_count, 0, sizeof(key_count));
//    memset(ls, 0, sizeof(ls));
//    memset(rs, 0, sizeof(rs));
//    memset(siz, 0, sizeof(siz));
//    memset(diff, 0, sizeof(diff));
//    cnt = 0;
//    head = 0;
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    int n;
//    cin >> n;
//    for (int i = 1; i <= n; i++) {
//        int op, x;
//        cin >> op >> x;
//        if (op == 1) {
//            add(x);
//        } else if (op == 2) {
//            remove(x);
//        } else if (op == 3) {
//            cout << getRank(x) << "\n";
//        } else if (op == 4) {
//            cout << index(x) << "\n";
//        } else if (op == 5) {
//            cout << pre(x) << "\n";
//        } else {
//            cout << post(x) << "\n";
//        }
//    }
//    clear();
//    return 0;
//}

package class151;

// 笛卡尔树模版(C++版)
// 给定一个长度为n的数组arr，下标从1开始
// 构建一棵二叉树，下标按照搜索二叉树组织，值按照小根堆组织
// 建树的过程要求时间复杂度O(n)
// 建树之后，为了验证
// 打印，i * (left[i] + 1)，所有信息异或起来的值
// 打印，i * (right[i] + 1)，所有信息异或起来的值
// 1 <= n <= 10^7
// 测试链接 : https://www.luogu.com.cn/problem/P5854
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <iostream>
//#include <vector>
//#include <stack>
//#include <cstdio>
//
//#define LL long long
//
//using namespace std;
//
//const int MAXN = 10000001;
//
//int arr[MAXN];
//int ls[MAXN];
//int rs[MAXN];
//int sta[MAXN];
//int n;
//
//void build() {
//    int top = 0;
//    for (int i = 1; i <= n; i++) {
//        int pos = top;
//        while (pos > 0 && arr[sta[pos]] > arr[i]) {
//            pos--;
//        }
//        if (pos > 0) {
//            rs[sta[pos]] = i;
//        }
//        if (pos < top) {
//            ls[i] = sta[pos + 1];
//        }
//        sta[++pos] = i;
//        top = pos;
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    build();
//    long long ans1 = 0, ans2 = 0;
//    for (int i = 1; i <= n; i++) {
//        ans1 ^= 1LL * i * (ls[i] + 1);
//        ans2 ^= 1LL * i * (rs[i] + 1);
//    }
//    cout << ans1 << " " << ans2 << endl;
//    return 0;
//}

package class152;

// FHQ-Treap，使用词频压缩，C++版
// 实现一种结构，支持如下操作，要求单次调用的时间复杂度O(log n)
// 1，增加x，重复加入算多个词频
// 2，删除x，如果有多个，只删掉一个
// 3，查询x的排名，x的排名为，比x小的数的个数+1
// 4，查询数据中排名为x的数
// 5，查询x的前驱，x的前驱为，小于x的数中最大的数，不存在返回整数最小值
// 6，查询x的后继，x的后继为，大于x的数中最小的数，不存在返回整数最大值
// 所有操作的次数 <= 10^5
// -10^7 <= x <= +10^7
// 测试链接 : https://www.luogu.com.cn/problem/P3369
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <iostream>
//#include <cstdio>
//#include <cstdlib>
//#include <cstring>
//#include <algorithm>
//#include <climits>
//using namespace std;
//
//const int MAXN = 100001;
//int head = 0;
//int cnt = 0;
//int key[MAXN];
//int key_count[MAXN];
//int ls[MAXN];
//int rs[MAXN];
//int siz[MAXN];
//double priority[MAXN];
//
//void up(int i) {
//    siz[i] = siz[ls[i]] + siz[rs[i]] + key_count[i];
//}
//
//void split(int l, int r, int i, int num) {
//    if (i == 0) {
//        rs[l] = ls[r] = 0;
//    } else {
//        if (key[i] <= num) {
//            rs[l] = i;
//            split(i, r, rs[i], num);
//        } else {
//            ls[r] = i;
//            split(l, i, ls[i], num);
//        }
//        up(i);
//    }
//}
//
//int merge(int l, int r) {
//    if (l == 0 || r == 0) {
//        return l + r;
//    }
//    if (priority[l] >= priority[r]) {
//        rs[l] = merge(rs[l], r);
//        up(l);
//        return l;
//    } else {
//        ls[r] = merge(l, ls[r]);
//        up(r);
//        return r;
//    }
//}
//
//int find(int i, int num) {
//    if (i == 0) {
//        return 0;
//    }
//    if (key[i] == num) {
//        return i;
//    } else if (key[i] > num) {
//        return find(ls[i], num);
//    } else {
//        return find(rs[i], num);
//    }
//}
//
//void changeCount(int i, int num, int change) {
//    if (key[i] == num) {
//        key_count[i] += change;
//    } else if (key[i] > num) {
//        changeCount(ls[i], num, change);
//    } else {
//        changeCount(rs[i], num, change);
//    }
//    up(i);
//}
//
//void add(int num) {
//    if (find(head, num) != 0) {
//        changeCount(head, num, 1);
//    } else {
//        split(0, 0, head, num);
//        key[++cnt] = num;
//        key_count[cnt] = siz[cnt] = 1;
//        priority[cnt] = (double)rand() / RAND_MAX;
//        head = merge(merge(rs[0], cnt), ls[0]);
//    }
//}
//
//void remove(int num) {
//    int i = find(head, num);
//    if (i != 0) {
//        if (key_count[i] > 1) {
//            changeCount(head, num, -1);
//        } else {
//            split(0, 0, head, num);
//            int lm = rs[0];
//            int r = ls[0];
//            split(0, 0, lm, num - 1);
//            int l = rs[0];
//            head = merge(l, r);
//        }
//    }
//}
//
//int small(int i, int num) {
//    if (i == 0) {
//        return 0;
//    }
//    if (key[i] >= num) {
//        return small(ls[i], num);
//    } else {
//        return siz[ls[i]] + key_count[i] + small(rs[i], num);
//    }
//}
//
//int getRank(int num) {
//    return small(head, num) + 1;
//}
//
//int index(int i, int x) {
//    if (siz[ls[i]] >= x) {
//        return index(ls[i], x);
//    } else if (siz[ls[i]] + key_count[i] < x) {
//        return index(rs[i], x - siz[ls[i]] - key_count[i]);
//    }
//    return key[i];
//}
//
//int index(int x) {
//    return index(head, x);
//}
//
//int pre(int i, int num) {
//    if (i == 0) {
//        return INT_MIN;
//    }
//    if (key[i] >= num) {
//        return pre(ls[i], num);
//    } else {
//        return max(key[i], pre(rs[i], num));
//    }
//}
//
//int pre(int num) {
//    return pre(head, num);
//}
//
//int post(int i, int num) {
//    if (i == 0) {
//        return INT_MAX;
//    }
//    if (key[i] <= num) {
//        return post(rs[i], num);
//    } else {
//        return min(key[i], post(ls[i], num));
//    }
//}
//
//int post(int num) {
//    return post(head, num);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    srand(time(0));
//    int n;
//    cin >> n;
//    for (int i = 1, op, x; i <= n; i++) {
//        cin >> op >> x;
//        if (op == 1) {
//            add(x);
//        } else if (op == 2) {
//            remove(x);
//        } else if (op == 3) {
//            cout << getRank(x) << endl;
//        } else if (op == 4) {
//            cout << index(x) << endl;
//        } else if (op == 5) {
//            cout << pre(x) << endl;
//        } else {
//            cout << post(x) << endl;
//        }
//    }
//    return 0;
//}

package class153;

// Splay树的实现，不用词频压缩，C++版
// 实现一种结构，支持如下操作，要求单次调用的时间复杂度O(log n)
// 1，增加x，重复加入算多个词频
// 2，删除x，如果有多个，只删掉一个
// 3，查询x的排名，x的排名为，比x小的数的个数+1
// 4，查询数据中排名为x的数
// 5，查询x的前驱，x的前驱为，小于x的数中最大的数，不存在返回整数最小值
// 6，查询x的后继，x的后继为，大于x的数中最小的数，不存在返回整数最大值
// 所有操作的次数 <= 10^5
// -10^7 <= x <= +10^7
// 测试链接 : https://www.luogu.com.cn/problem/P3369
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <iostream>
//#include <vector>
//#include <algorithm>
//#include <climits>
//
//using namespace std;
//
//const int MAXN = 100001;
//
//int head = 0;
//int cnt = 0;
//int key[MAXN];
//int fa[MAXN];
//int ls[MAXN];
//int rs[MAXN];
//int siz[MAXN];
//
//void up(int i) {
//    siz[i] = siz[ls[i]] + siz[rs[i]] + 1;
//}
//
//int lr(int i) {
//    return rs[fa[i]] == i ? 1 : 0;
//}
//
//void rotate(int i) {
//    int f = fa[i], g = fa[f], soni = lr(i), sonf = lr(f);
//    if (soni == 1) {
//        rs[f] = ls[i];
//        if (rs[f] != 0) {
//            fa[rs[f]] = f;
//        }
//        ls[i] = f;
//    } else {
//        ls[f] = rs[i];
//        if (ls[f] != 0) {
//            fa[ls[f]] = f;
//        }
//        rs[i] = f;
//    }
//    if (g != 0) {
//        if (sonf == 1) {
//            rs[g] = i;
//        } else {
//            ls[g] = i;
//        }
//    }
//    fa[f] = i;
//    fa[i] = g;
//    up(f);
//    up(i);
//}
//
//void splay(int i, int goal) {
//    int f = fa[i], g = fa[f];
//    while (f != goal) {
//        if (g != goal) {
//            if (lr(i) == lr(f)) {
//                rotate(f);
//            } else {
//                rotate(i);
//            }
//        }
//        rotate(i);
//        f = fa[i];
//        g = fa[f];
//    }
//    if (goal == 0) {
//        head = i;
//    }
//}
//
//int find(int rank) {
//    int i = head;
//    while (i != 0) {
//        if (siz[ls[i]] + 1 == rank) {
//            return i;
//        } else if (siz[ls[i]] >= rank) {
//            i = ls[i];
//        } else {
//            rank -= siz[ls[i]] + 1;
//            i = rs[i];
//        }
//    }
//    return 0;
//}
//
//void add(int num) {
//    key[++cnt] = num;
//    siz[cnt] = 1;
//    if (head == 0) {
//        head = cnt;
//    } else {
//        int f = 0, i = head, son = 0;
//        while (i != 0) {
//            f = i;
//            if (key[i] <= num) {
//                son = 1;
//                i = rs[i];
//            } else {
//                son = 0;
//                i = ls[i];
//            }
//        }
//        if (son == 1) {
//            rs[f] = cnt;
//        } else {
//            ls[f] = cnt;
//        }
//        fa[cnt] = f;
//        splay(cnt, 0);
//    }
//}
//
//int getRank(int num) {
//    int i = head, last = head;
//    int ans = 0;
//    while (i != 0) {
//        last = i;
//        if (key[i] >= num) {
//            i = ls[i];
//        } else {
//            ans += siz[ls[i]] + 1;
//            i = rs[i];
//        }
//    }
//    splay(last, 0);
//    return ans + 1;
//}
//
//int index(int x) {
//    int i = find(x);
//    splay(i, 0);
//    return key[i];
//}
//
//int pre(int num) {
//    int i = head, last = head;
//    int ans = INT_MIN;
//    while (i != 0) {
//        last = i;
//        if (key[i] >= num) {
//            i = ls[i];
//        } else {
//            ans = max(ans, key[i]);
//            i = rs[i];
//        }
//    }
//    splay(last, 0);
//    return ans;
//}
//
//int post(int num) {
//    int i = head, last = head;
//    int ans = INT_MAX;
//    while (i != 0) {
//        last = i;
//        if (key[i] <= num) {
//            i = rs[i];
//        } else {
//            ans = min(ans, key[i]);
//            i = ls[i];
//        }
//    }
//    splay(last, 0);
//    return ans;
//}
//
//void remove(int num) {
//    int kth = getRank(num);
//    if (kth != getRank(num + 1)) {
//        int i = find(kth);
//        splay(i, 0);
//        if (ls[i] == 0) {
//            head = rs[i];
//        } else if (rs[i] == 0) {
//            head = ls[i];
//        } else {
//            int j = find(kth + 1);
//            splay(j, i);
//            ls[j] = ls[i];
//            fa[ls[j]] = j;
//            up(j);
//            head = j;
//        }
//        if (head != 0) {
//            fa[head] = 0;
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    int n;
//    cin >> n;
//    for (int i = 0, op, x; i < n; i++) {
//        cin >> op >> x;
//        if (op == 1) {
//            add(x);
//        } else if (op == 2) {
//            remove(x);
//        } else if (op == 3) {
//            cout << getRank(x) << endl;
//        } else if (op == 4) {
//            cout << index(x) << endl;
//        } else if (op == 5) {
//            cout << pre(x) << endl;
//        } else {
//            cout << post(x) << endl;
//        }
//    }
//    return 0;
//}


package class157;

// 范围修改的可持久化线段树，经典的方式，C++版
// 给定一个长度为n的数组arr，下标1~n，时间戳t=0，arr认为是0版本的数组
// 一共有m条操作，每条操作为如下四种类型中的一种
// C x y z : 当前时间戳t版本的数组，[x..y]范围每个数字增加z，得到t+1版本数组，并且t++
// Q x y   : 当前时间戳t版本的数组，打印[x..y]范围累加和
// H x y z : z版本的数组，打印[x..y]范围的累加和
// B x     : 当前时间戳t设置成x
// 1 <= n、m <= 10^5
// -10^9 <= arr[i] <= +10^9
// 测试链接 : https://www.luogu.com.cn/problem/SP11470
// 测试链接 : https://www.spoj.com/problems/TTM
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
// 
//const int MAXN = 100001;
//const int MAXT = MAXN * 70;
//int n, m, t = 0;
//int arr[MAXN];
//int root[MAXN];
//int ls[MAXT];
//int rs[MAXT];
//long long sum[MAXT];
//long long add[MAXT];
//int cnt = 0;
// 
//int clone(int i) {
//    int rt = ++cnt;
//    ls[rt] = ls[i];
//    rs[rt] = rs[i];
//    sum[rt] = sum[i];
//    add[rt] = add[i];
//    return rt;
//}
// 
//void up(int i) {
//    sum[i] = sum[ls[i]] + sum[rs[i]];
//}
// 
//void lazy(int i, long long v, int n) {
//    sum[i] += v * n;
//    add[i] += v;
//}
// 
//void down(int i, int ln, int rn) {
//    if (add[i] != 0) {
//        ls[i] = clone(ls[i]);
//        rs[i] = clone(rs[i]);
//        lazy(ls[i], add[i], ln);
//        lazy(rs[i], add[i], rn);
//        add[i] = 0;
//    }
//}
// 
//int build(int l, int r) {
//    int rt = ++cnt;
//    add[rt] = 0;
//    if (l == r) {
//        sum[rt] = arr[l];
//    } else {
//        int mid = (l + r) / 2;
//        ls[rt] = build(l, mid);
//        rs[rt] = build(mid + 1, r);
//        up(rt);
//    }
//    return rt;
//}
// 
//int addRange(int jobl, int jobr, long long jobv, int l, int r, int i) {
//    int rt = clone(i);
//    if (jobl <= l && r <= jobr) {
//        lazy(rt, jobv, r - l + 1);
//    } else {
//        int mid = (l + r) / 2;
//        down(rt, mid - l + 1, r - mid);
//        if (jobl <= mid) {
//            ls[rt] = addRange(jobl, jobr, jobv, l, mid, ls[rt]);
//        }
//        if (jobr > mid) {
//            rs[rt] = addRange(jobl, jobr, jobv, mid + 1, r, rs[rt]);
//        }
//        up(rt);
//    }
//    return rt;
//}
// 
//long long query(int jobl, int jobr, int l, int r, int i) {
//    if (jobl <= l && r <= jobr) {
//        return sum[i];
//    }
//    int mid = (l + r) / 2;
//    down(i, mid - l + 1, r - mid);
//    long long ans = 0;
//    if (jobl <= mid) {
//        ans += query(jobl, jobr, l, mid, ls[i]);
//    }
//    if (jobr > mid) {
//        ans += query(jobl, jobr, mid + 1, r, rs[i]);
//    }
//    return ans;
//}
// 
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    root[0] = build(1, n);
//    string op;
//    int x, y, z;
//    for (int i = 1; i <= m; i++) {
//        cin >> op;
//        if (op == "C") {
//            cin >> x >> y >> z;
//            root[t + 1] = addRange(x, y, z, 1, n, root[t]);
//            t++;
//        } else if (op == "Q") {
//            cin >> x >> y;
//            cout << query(x, y, 1, n, root[t]) << "\n";
//        } else if (op == "H") {
//            cin >> x >> y >> z;
//            cout << query(x, y, 1, n, root[z]) << "\n";
//        } else if (op == "B") {
//            cin >> x;
//            t = x;
//        }
//    }
//    return 0;
//}

package class158;

// 区间内没有出现的最小自然数，C++版
// 给定一个长度为n的数组arr，下标1~n，一共有m条查询
// 每条查询 l r : 打印arr[l..r]内没有出现过的最小自然数，注意0是自然数
// 请用在线算法解决该问题，因为可以设计强制在线的要求，让离线算法失效
// 1 <= n、m <= 2 * 10^5
// 0 <= arr[i] <= 2 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P4137
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 200001;
//const int MAXT = MAXN * 22;
//int n, m;
//int arr[MAXN];
//int root[MAXN];
//int ls[MAXT];
//int rs[MAXT];
//int lateLeft[MAXT];
//int cnt;
//
//int build(int l, int r) {
//    int rt = ++cnt;
//    lateLeft[rt] = 0;
//    if (l < r) {
//        int mid = (l + r) / 2;
//        ls[rt] = build(l, mid);
//        rs[rt] = build(mid + 1, r);
//    }
//    return rt;
//}
//
//int update(int jobi, int jobv, int l, int r, int i) {
//    int rt = ++cnt;
//    ls[rt] = ls[i];
//    rs[rt] = rs[i];
//    lateLeft[rt] = lateLeft[i];
//    if (l == r) {
//        lateLeft[rt] = jobv;
//    } else {
//        int mid = (l + r) / 2;
//        if (jobi <= mid) {
//            ls[rt] = update(jobi, jobv, l, mid, ls[rt]);
//        } else {
//            rs[rt] = update(jobi, jobv, mid + 1, r, rs[rt]);
//        }
//        lateLeft[rt] = min(lateLeft[ls[rt]], lateLeft[rs[rt]]);
//    }
//    return rt;
//}
//
//int query(int pos, int l, int r, int i) {
//    if (l == r) {
//        return l;
//    }
//    int mid = (l + r) / 2;
//    if (lateLeft[ls[i]] < pos) {
//        return query(pos, l, mid, ls[i]);
//    } else {
//        return query(pos, mid + 1, r, rs[i]);
//    }
//}
//
//void prepare() {
//    cnt = 0;
//    root[0] = build(0, n);
//    for (int i = 1; i <= n; i++) {
//        if (arr[i] > n || arr[i] < 0) {
//            root[i] = root[i - 1];
//        } else {
//            root[i] = update(arr[i], i, 0, n, root[i - 1]);
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    for (int i = 1, l, r; i <= m; i++) {
//        cin >> l >> r;
//        cout << query(l, 0, n, root[r]) << "\n";
//    }
//    return 0;
//}

package class159;

// 最大异或和，C++版
// 非负序列arr的初始长度为n，一共有m条操作，每条操作是如下两种类型中的一种
// A x     : arr的末尾增加数字x，arr的长度n也增加1
// Q l r x : l~r这些位置中，选一个位置p，现在希望
//           arr[p] ^ arr[p+1] ^ .. ^ arr[n] ^ x 这个值最大
//           打印这个最大值
// 1 <= n、m <= 3 * 10^5
// 0 <= arr[i]、x <= 10^7
// 因为练的就是可持久化前缀树，所以就用在线算法，不要使用离线算法
// 测试链接 : https://www.luogu.com.cn/problem/P4735
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 600001;
//const int MAXT = MAXN * 22;
//const int BIT = 25;
//int n, m, eor;
//int root[MAXN];
//int tree[MAXT][2];
//int pass[MAXT];
//int cnt = 0;
//
//int insert(int num, int i) {
//    int rt = ++cnt;
//    tree[rt][0] = tree[i][0];
//    tree[rt][1] = tree[i][1];
//    pass[rt] = pass[i] + 1;
//    for (int b = BIT, path, pre = rt, cur; b >= 0; b--, pre = cur) {
//        path = (num >> b) & 1;
//        i = tree[i][path];
//        cur = ++cnt;
//        tree[cur][0] = tree[i][0];
//        tree[cur][1] = tree[i][1];
//        pass[cur] = pass[i] + 1;
//        tree[pre][path] = cur;
//    }
//    return rt;
//}
//
//int query(int num, int u, int v) {
//    int ans = 0;
//    for (int b = BIT, path, best; b >= 0; b--) {
//        path = (num >> b) & 1;
//        best = path ^ 1;
//        if (pass[tree[v][best]] > pass[tree[u][best]]) {
//            ans += 1 << b;
//            u = tree[u][best];
//            v = tree[v][best];
//        } else {
//            u = tree[u][path];
//            v = tree[v][path];
//        }
//    }
//    return ans;
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(0);
//    cin >> n >> m;
//    eor = 0;
//    root[0] = insert(eor, 0);
//    for (int i = 1, num; i <= n; i++) {
//        cin >> num;
//        eor ^= num;
//        root[i] = insert(eor, root[i - 1]);
//    }
//    string op;
//    int x, y, z;
//    for (int i = 1; i <= m; i++) {
//        cin >> op;
//        if (op == "A") {
//            cin >> x;
//            eor ^= x;
//            n++;
//            root[n] = insert(eor, root[n - 1]);
//        } else {
//            cin >> x >> y >> z;
//            if (x == 1) {
//                cout << query(eor ^ z, 0, root[y - 1]) << "\n";
//            } else {
//                cout << query(eor ^ z, root[x - 2], root[y - 1]) << "\n";
//            }
//        }
//    }
//    return 0;
//}

package class159;

// 路径和子树的异或，C++版
// 一共有n个节点，n-1条边，组成一棵树，1号节点为树头，每个节点给定点权
// 一共有m条查询，每条查询是如下两种类型中的一种
// 1 x y   : 以x为头的子树中任选一个值，希望异或y之后的值最大，打印最大值
// 2 x y z : 节点x到节点y的路径中任选一个值，希望异或z之后的值最大，打印最大值
// 2 <= n、m <= 10^5
// 1 <= 点权、z < 2^30
// 测试链接 : https://www.luogu.com.cn/problem/P4592
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//const int MAXT = MAXN * 62;
//const int MAXH = 16;
//const int BIT = 29;
//int n, m;
//int arr[MAXN];
//
//int head[MAXN];
//int nxt[MAXN << 1];
//int to[MAXN << 1];
//int cntg = 0;
//
//int deep[MAXN];
//int siz[MAXN];
//int stjump[MAXN][MAXH];
//int dfn[MAXN];
//int cntd = 0;
//
//int root1[MAXN];
//int root2[MAXN];
//int tree[MAXT][2];
//int pass[MAXT];
//int cntt = 0;
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//int insert(int num, int i) {
//    int rt = ++cntt;
//    tree[rt][0] = tree[i][0];
//    tree[rt][1] = tree[i][1];
//    pass[rt] = pass[i] + 1;
//    for (int b = BIT, path, pre = rt, cur; b >= 0; b--, pre = cur) {
//        path = (num >> b) & 1;
//        i = tree[i][path];
//        cur = ++cntt;
//        tree[cur][0] = tree[i][0];
//        tree[cur][1] = tree[i][1];
//        pass[cur] = pass[i] + 1;
//        tree[pre][path] = cur;
//    }
//    return rt;
//}
//
//int query(int num, int u, int v) {
//    int ans = 0;
//    for (int b = BIT, path, best; b >= 0; b--) {
//        path = (num >> b) & 1;
//        best = path ^ 1;
//        if (pass[tree[v][best]] > pass[tree[u][best]]) {
//            ans += (1 << b);
//            u = tree[u][best];
//            v = tree[v][best];
//        } else {
//            u = tree[u][path];
//            v = tree[v][path];
//        }
//    }
//    return ans;
//}
//
//void dfs1(int u, int fa) {
//    deep[u] = deep[fa] + 1;
//    siz[u] = 1;
//    stjump[u][0] = fa;
//    dfn[u] = ++cntd;
//    for (int p = 1; p < MAXH; p++) {
//        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
//    }
//    for (int ei = head[u], v; ei > 0; ei = nxt[ei]) {
//        v = to[ei];
//        if (v != fa) {
//            dfs1(v, u);
//            siz[u] += siz[v];
//        }
//    }
//}
//
//void dfs2(int u, int fa) {
//    root1[dfn[u]] = insert(arr[u], root1[dfn[u] - 1]);
//    root2[u] = insert(arr[u], root2[fa]);
//    for (int ei = head[u]; ei > 0; ei = nxt[ei]) {
//        if (to[ei] != fa) {
//            dfs2(to[ei], u);
//        }
//    }
//}
//
//int lca(int a, int b) {
//    if (deep[a] < deep[b]) {
//        swap(a, b);
//    }
//    for (int p = MAXH - 1; p >= 0; p--) {
//        if (deep[stjump[a][p]] >= deep[b]) {
//            a = stjump[a][p];
//        }
//    }
//    if (a == b) {
//        return a;
//    }
//    for (int p = MAXH - 1; p >= 0; p--) {
//        if (stjump[a][p] != stjump[b][p]) {
//            a = stjump[a][p];
//            b = stjump[b][p];
//        }
//    }
//    return stjump[a][0];
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1, u, v; i < n; i++) {
//        cin >> u >> v;
//        addEdge(u, v);
//        addEdge(v, u);
//    }
//    dfs1(1, 0);
//    dfs2(1, 0);
//    for (int i = 1, op, x, y, z; i <= m; i++) {
//        cin >> op >> x >> y;
//        if (op == 1) {
//            cout << query(y, root1[dfn[x] - 1], root1[dfn[x] + siz[x] - 1]) << '\n';
//        } else {
//            cin >> z;
//            int lcafa = stjump[lca(x, y)][0];
//            int ans = max(query(z, root2[lcafa], root2[x]), query(z, root2[lcafa], root2[y]));
//            cout << ans << '\n';
//        }
//    }
//    return 0;
//}

package class160;

// 线段树套线段树，C++版
// 人有三种属性，身高、活泼度、缘分值
// 身高为int类型，活泼度和缘分值为小数点后最多1位的double类型
// 实现一种结构，提供如下两种类型的操作
// 操作 I a b c   : 加入一个人，身高为a，活泼度为b，缘分值为c
// 操作 Q a b c d : 查询身高范围[a,b]，活泼度范围[c,d]，所有人中的缘分最大值
// 注意操作Q，如果a > b需要交换，如果c > d需要交换
// 100 <= 身高 <= 200
// 0.0 <= 活泼度、缘分值 <= 100.0
// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=1823
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int n = 101;
//const int m = 1001;
//int MINX = 100, MAXX = 200, MINY = 0, MAXY = 1000;
//int tree[n << 2][m << 2];
//
//void innerBuild(int yl, int yr, int xi, int yi) {
//    tree[xi][yi] = -1;
//    if (yl < yr) {
//        int mid = (yl + yr) >> 1;
//        innerBuild(yl, mid, xi, yi << 1);
//        innerBuild(mid + 1, yr, xi, yi << 1 | 1);
//    }
//}
//
//void innerUpdate(int jobi, int jobv, int yl, int yr, int xi, int yi) {
//    if (yl == yr) {
//        tree[xi][yi] = max(tree[xi][yi], jobv);
//    } else {
//        int mid = (yl + yr) >> 1;
//        if (jobi <= mid) {
//        	innerUpdate(jobi, jobv, yl, mid, xi, yi << 1);
//        } else {
//        	innerUpdate(jobi, jobv, mid + 1, yr, xi, yi << 1 | 1);
//        }
//        tree[xi][yi] = max(tree[xi][yi << 1], tree[xi][(yi << 1) | 1]);
//    }
//}
//
//int innerQuery(int jobl, int jobr, int yl, int yr, int xi, int yi) {
//    if (jobl <= yl && yr <= jobr) {
//        return tree[xi][yi];
//    }
//    int mid = (yl + yr) >> 1;
//    int ans = -1;
//    if (jobl <= mid) {
//        ans = max(ans, innerQuery(jobl, jobr, yl, mid, xi, yi << 1));
//    }
//    if (jobr > mid) {
//        ans = max(ans, innerQuery(jobl, jobr, mid + 1, yr, xi, (yi << 1) | 1));
//    }
//    return ans;
//}
//
//void outerBuild(int xl, int xr, int xi) {
//	innerBuild(MINY, MAXY, xi, 1);
//    if (xl < xr) {
//        int mid = (xl + xr) >> 1;
//        outerBuild(xl, mid, xi << 1);
//        outerBuild(mid + 1, xr, xi << 1 | 1);
//    }
//}
//
//void outerUpdate(int jobx, int joby, int jobv, int xl, int xr, int xi) {
//	innerUpdate(joby, jobv, MINY, MAXY, xi, 1);
//    if (xl < xr) {
//        int mid = (xl + xr) >> 1;
//        if (jobx <= mid) {
//        	outerUpdate(jobx, joby, jobv, xl, mid, xi << 1);
//        } else {
//        	outerUpdate(jobx, joby, jobv, mid + 1, xr, xi << 1 | 1);
//        }
//    }
//}
//
//int outerQuery(int jobxl, int jobxr, int jobyl, int jobyr, int xl, int xr, int xi) {
//    if (jobxl <= xl && xr <= jobxr) {
//        return innerQuery(jobyl, jobyr, MINY, MAXY, xi, 1);
//    }
//    int mid = (xl + xr) >> 1;
//    int ans = -1;
//    if (jobxl <= mid) {
//        ans = max(ans, outerQuery(jobxl, jobxr, jobyl, jobyr, xl, mid, xi << 1));
//    }
//    if (jobxr > mid) {
//        ans = max(ans, outerQuery(jobxl, jobxr, jobyl, jobyr, mid + 1, xr, (xi << 1) | 1));
//    }
//    return ans;
//}
//
//int main() {
//	int q;
//	scanf("%d", &q);
//	while(q != 0) {
//		outerBuild(MINX, MAXX, 1);
//        for (int i = 0; i < q; i++) {
//        	char op[2];
//            scanf("%s", op);
//            if (op[0] == 'I') {
//                int a;
//                double b, c;
//                scanf("%d %lf %lf", &a, &b, &c);
//                outerUpdate(a, (int)(b * 10), (int)(c * 10), MINX, MAXX, 1);
//            } else {
//                int a, b;
//                double c, d;
//                scanf("%d %d %lf %lf", &a, &b, &c, &d);
//                int xl = min(a, b);
//                int xr = max(a, b);
//                int yl = min((int)(c * 10), (int)(d * 10));
//                int yr = max((int)(c * 10), (int)(d * 10));
//                int ans = outerQuery(xl, xr, yl, yr, MINX, MAXX, 1);
//                if (ans == -1) {
//                    printf("-1\n");
//                } else {
//                    printf("%.1f\n", ans / 10.0);
//                }
//            }
//        }
//        scanf("%d", &q);
//	}
//    return 0;
//}
package class160;

// k大数查询，C++版
// 初始时有n个空集合，编号1~n，实现如下两种类型的操作，操作一共发生m次
// 操作 1 l r v : 数字v放入编号范围[l,r]的每一个集合中
// 操作 2 l r k : 编号范围[l,r]的所有集合，如果生成不去重的并集，返回第k大的数字
// 1 <= n、m <= 5 * 10^4
// -n <= v <= +n
// 1 <= k < 2^63，题目保证第k大的数字一定存在
// 测试链接 : https://www.luogu.com.cn/problem/P3332
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXM = 50001;
//const int MAXT = MAXM * 230;
//int n, m, s;
//int ques[MAXM][4];
//int sorted[MAXM];
//int root[MAXM << 2];
//int ls[MAXT];
//int rs[MAXT];
//long long sum[MAXT];
//int lazy[MAXT];
//int cnt;
//
//int kth(int num) {
//    int l = 1, r = s;
//    while (l <= r) {
//        int mid = (l + r) >> 1;
//        if (sorted[mid] == num) {
//            return mid;
//        } else if (sorted[mid] < num) {
//            l = mid + 1;
//        } else {
//            r = mid - 1;
//        }
//    }
//    return -1;
//}
//
//void up(int i) {
//    sum[i] = sum[ls[i]] + sum[rs[i]];
//}
//
//void down(int i, int ln, int rn) {
//    if (lazy[i]) {
//        if (!ls[i]) ls[i] = ++cnt;
//        if (!rs[i]) rs[i] = ++cnt;
//        sum[ls[i]] += 1LL * lazy[i] * ln;
//        lazy[ls[i]] += lazy[i];
//        sum[rs[i]] += 1LL * lazy[i] * rn;
//        lazy[rs[i]] += lazy[i];
//        lazy[i] = 0;
//    }
//}
//
//int innerAdd(int jobl, int jobr, int l, int r, int i) {
//    if (!i) i = ++cnt;
//    if (jobl <= l && r <= jobr) {
//        sum[i] += (long long)(r - l + 1);
//        lazy[i]++;
//    } else {
//        int mid = (l + r) >> 1;
//        down(i, mid - l + 1, r - mid);
//        if (jobl <= mid) ls[i] = innerAdd(jobl, jobr, l, mid, ls[i]);
//        if (jobr > mid) rs[i] = innerAdd(jobl, jobr, mid + 1, r, rs[i]);
//        up(i);
//    }
//    return i;
//}
//
//long long innerQuery(int jobl, int jobr, int l, int r, int i) {
//    if (!i) return 0;
//    if (jobl <= l && r <= jobr) {
//        return sum[i];
//    }
//    int mid = (l + r) >> 1;
//    down(i, mid - l + 1, r - mid);
//    long long ans = 0;
//    if (jobl <= mid) ans += innerQuery(jobl, jobr, l, mid, ls[i]);
//    if (jobr > mid) ans += innerQuery(jobl, jobr, mid + 1, r, rs[i]);
//    return ans;
//}
//
//void outerAdd(int jobl, int jobr, int jobv, int l, int r, int i) {
//    root[i] = innerAdd(jobl, jobr, 1, n, root[i]);
//    if (l < r) {
//        int mid = (l + r) >> 1;
//        if (jobv <= mid) {
//            outerAdd(jobl, jobr, jobv, l, mid, i << 1);
//        } else {
//            outerAdd(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
//        }
//    }
//}
//
//int outerQuery(int jobl, int jobr, long long jobk, int l, int r, int i) {
//    if (l == r) {
//        return l;
//    }
//    int mid = (l + r) >> 1;
//    long long rightsum = innerQuery(jobl, jobr, 1, n, root[i << 1 | 1]);
//    if (jobk > rightsum) {
//        return outerQuery(jobl, jobr, jobk - rightsum, l, mid, i << 1);
//    } else {
//        return outerQuery(jobl, jobr, jobk, mid + 1, r, i << 1 | 1);
//    }
//}
//
//void prepare() {
//    s = 0;
//    for (int i = 1; i <= m; i++) {
//        if (ques[i][0] == 1) {
//            sorted[++s] = ques[i][3];
//        }
//    }
//    sort(sorted + 1, sorted + s + 1);
//    int len = 1;
//    for (int i = 2; i <= s; i++) {
//        if (sorted[len] != sorted[i]) {
//            sorted[++len] = sorted[i];
//        }
//    }
//    s = len;
//    for (int i = 1; i <= m; i++) {
//        if (ques[i][0] == 1) {
//            ques[i][3] = kth(ques[i][3]);
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= m; i++) {
//        cin >> ques[i][0] >> ques[i][1] >> ques[i][2] >> ques[i][3];
//    }
//    prepare();
//    for (int i = 1; i <= m; i++) {
//        if (ques[i][0] == 1) {
//            outerAdd(ques[i][1], ques[i][2], ques[i][3], 1, s, 1);
//        } else {
//            int idx = outerQuery(ques[i][1], ques[i][2], ques[i][3], 1, s, 1);
//            cout << sorted[idx] << "\n";
//        }
//    }
//    return 0;
//}

package class160;

// 树状数组套线段树，C++版
// 给定一个长度为n的数组arr，下标1~n，每条操作都是如下5种类型中的一种，一共进行m次操作
// 操作 1 x y z : 查询数字z在arr[x..y]中的排名
// 操作 2 x y z : 查询arr[x..y]中排第z名的数字
// 操作 3 x y   : arr中x位置的数字改成y
// 操作 4 x y z : 查询数字z在arr[x..y]中的前驱，不存在返回-2147483647
// 操作 5 x y z : 查询数字z在arr[x..y]中的后继，不存在返回+2147483647
// 1 <= n、m <= 5 * 10^4
// 数组中的值永远在[0, 10^8]范围内
// 测试链接 : https://www.luogu.com.cn/problem/P3380
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 50001;
//const int MAXT = MAXN * 160;
//const int INF = INT_MAX;
//int n, m, s;
//int arr[MAXN];
//int ques[MAXN][4];
//int sorted[MAXN * 2];
//int root[MAXN];
//int sum[MAXT];
//int ls[MAXT];
//int rs[MAXT];
//int cntt = 0;
//int addTree[MAXN];
//int minusTree[MAXN];
//int cntadd;
//int cntminus;
//
//int kth(int num) {
//    int left = 1, right = s, mid;
//    while (left <= right) {
//        mid = (left + right) / 2;
//        if (sorted[mid] == num) {
//            return mid;
//        } else if (sorted[mid] < num) {
//            left = mid + 1;
//        } else {
//            right = mid - 1;
//        }
//    }
//    return -1;
//}
//
//int lowbit(int i) {
//    return i & -i;
//}
//
//int innerAdd(int jobi, int jobv, int l, int r, int i) {
//    if (i == 0) {
//        i = ++cntt;
//    }
//    if (l == r) {
//        sum[i] += jobv;
//    } else {
//        int mid = (l + r) / 2;
//        if (jobi <= mid) {
//        	ls[i] = innerAdd(jobi, jobv, l, mid, ls[i]);
//        } else {
//        	rs[i] = innerAdd(jobi, jobv, mid + 1, r, rs[i]);
//        }
//        sum[i] = sum[ls[i]] + sum[rs[i]];
//    }
//    return i;
//}
//
//int innerQuery(int jobk, int l, int r) {
//    if (l == r) {
//        return l;
//    }
//    int mid = (l + r) / 2;
//    int leftsum = 0;
//    for (int i = 1; i <= cntadd; i++) {
//        leftsum += sum[ls[addTree[i]]];
//    }
//    for (int i = 1; i <= cntminus; i++) {
//        leftsum -= sum[ls[minusTree[i]]];
//    }
//    if (jobk <= leftsum) {
//        for (int i = 1; i <= cntadd; i++) {
//            addTree[i] = ls[addTree[i]];
//        }
//        for (int i = 1; i <= cntminus; i++) {
//            minusTree[i] = ls[minusTree[i]];
//        }
//        return innerQuery(jobk, l, mid);
//    } else {
//        for (int i = 1; i <= cntadd; i++) {
//            addTree[i] = rs[addTree[i]];
//        }
//        for (int i = 1; i <= cntminus; i++) {
//            minusTree[i] = rs[minusTree[i]];
//        }
//        return innerQuery(jobk - leftsum, mid + 1, r);
//    }
//}
//
//int innerSmall(int jobi, int l, int r) {
//    if (l == r) {
//        return 0;
//    }
//    int mid = (l + r) / 2;
//    if (jobi <= mid) {
//        for (int i = 1; i <= cntadd; i++) {
//            addTree[i] = ls[addTree[i]];
//        }
//        for (int i = 1; i <= cntminus; i++) {
//            minusTree[i] = ls[minusTree[i]];
//        }
//        return innerSmall(jobi, l, mid);
//    } else {
//        int leftsum = 0;
//        for (int i = 1; i <= cntadd; i++) {
//            leftsum += sum[ls[addTree[i]]];
//            addTree[i] = rs[addTree[i]];
//        }
//        for (int i = 1; i <= cntminus; i++) {
//            leftsum -= sum[ls[minusTree[i]]];
//            minusTree[i] = rs[minusTree[i]];
//        }
//        return leftsum + innerSmall(jobi, mid + 1, r);
//    }
//}
//
//void add(int i, int cnt) {
//    for (int j = i; j <= n; j += lowbit(j)) {
//        root[j] = innerAdd(arr[i], cnt, 1, s, root[j]);
//    }
//}
//
//void update(int i, int v) {
//    add(i, -1);
//    arr[i] = kth(v);
//    add(i, 1);
//}
//
//int small(int l, int r, int v) {
//    cntadd = cntminus = 0;
//    for (int i = r; i > 0; i -= lowbit(i)) {
//        addTree[++cntadd] = root[i];
//    }
//    for (int i = l - 1; i > 0; i -= lowbit(i)) {
//        minusTree[++cntminus] = root[i];
//    }
//    return innerSmall(v, 1, s);
//}
//
//int number(int l, int r, int k) {
//    cntadd = cntminus = 0;
//    for (int i = r; i > 0; i -= lowbit(i)) {
//        addTree[++cntadd] = root[i];
//    }
//    for (int i = l - 1; i > 0; i -= lowbit(i)) {
//        minusTree[++cntminus] = root[i];
//    }
//    return sorted[innerQuery(k, 1, s)];
//}
//
//int pre(int l, int r, int v) {
//    int rank = small(l, r, v) + 1;
//    if (rank == 1) {
//        return -INF;
//    }
//    return number(l, r, rank - 1);
//}
//
//int post(int l, int r, int v) {
//    if (v == s) {
//        return INF;
//    }
//    int sml = small(l, r, v + 1);
//    if (sml == r - l + 1) {
//        return INF;
//    }
//    return number(l, r, sml + 1);
//}
//
//void prepare() {
//    s = 0;
//    for (int i = 1; i <= n; i++) {
//        sorted[++s] = arr[i];
//    }
//    for (int i = 1; i <= m; i++) {
//        if (ques[i][0] == 3) {
//            sorted[++s] = ques[i][2];
//        } else if (ques[i][0] != 2) {
//            sorted[++s] = ques[i][3];
//        }
//    }
//    sort(sorted + 1, sorted + s + 1);
//    int len = 1;
//    for (int i = 2; i <= s; i++) {
//        if (sorted[len] != sorted[i]) {
//            sorted[++len] = sorted[i];
//        }
//    }
//    s = len;
//    for (int i = 1; i <= n; i++) {
//        arr[i] = kth(arr[i]);
//        add(i, 1);
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    cin >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1; i <= m; i++) {
//        cin >> ques[i][0];
//        cin >> ques[i][1];
//        cin >> ques[i][2];
//        if (ques[i][0] != 3) {
//            cin >> ques[i][3];
//        }
//    }
//    prepare();
//    for (int i = 1, op, x, y, z; i <= m; i++) {
//        op = ques[i][0];
//        x = ques[i][1];
//        y = ques[i][2];
//        if (op == 3) {
//            update(x, y);
//        } else {
//            z = ques[i][3];
//            if (op == 1) {
//                cout << small(x, y, kth(z)) + 1 << "\n";
//            } else if (op == 2) {
//                cout << number(x, y, z) << "\n";
//            } else if (op == 4) {
//                cout << pre(x, y, kth(z)) << "\n";
//            } else {
//                cout << post(x, y, kth(z)) << "\n";
//            }
//        }
//    }
//    return 0;
//}

package class161;

// 重链剖分模版题，C++版
// 一共有n个节点，给定n-1条边，节点连成一棵树
// 给定每个节点的初始权值，给定树的头节点编号root
// 一共有m条操作，每种操作是如下4种类型中的一种
// 操作 1 x y v : x到y的路径上，每个节点值增加v
// 操作 2 x y   : x到y的路径上，打印所有节点值的累加和
// 操作 3 x v   : x为头的子树上，每个节点值增加v
// 操作 4 x     : x为头的子树上，打印所有节点值的累加和
// 1 <= n、m <= 10^5
// 1 <= MOD <= 2^30
// 输入的值都为int类型
// 查询操作时，打印(查询结果 % MOD)，题目会给定MOD值
// 测试链接 : https://www.luogu.com.cn/problem/P3384
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//int n, m, root, MOD;
//int arr[MAXN];
//
//int head[MAXN];
//int nxt[MAXN << 1];
//int to[MAXN << 1];
//int cntg = 0;
//
//int fa[MAXN];
//int dep[MAXN];
//int siz[MAXN];
//int son[MAXN];
//int top[MAXN];
//int dfn[MAXN];
//int seg[MAXN];
//int cntd = 0;
//
//long long sum[MAXN << 2];
//long long addTag[MAXN << 2];
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//void dfs1(int u, int f) {
//    fa[u] = f;
//    dep[u] = dep[f] + 1;
//    siz[u] = 1;
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            dfs1(v, u);
//        }
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            siz[u] += siz[v];
//            if (son[u] == 0 || siz[son[u]] < siz[v]) {
//                son[u] = v;
//            }
//        }
//    }
//}
//
//void dfs2(int u, int t) {
//    top[u] = t;
//    dfn[u] = ++cntd;
//    seg[cntd] = u;
//    if (son[u] == 0) {
//        return;
//    }
//    dfs2(son[u], t);
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != fa[u] && v != son[u]) {
//            dfs2(v, v);
//        }
//    }
//}
//
//void up(int i) {
//    sum[i] = (sum[i << 1] + sum[i << 1 | 1]) % MOD;
//}
//
//void lazy(int i, long long v, int n) {
//    sum[i] = (sum[i] + v * n) % MOD;
//    addTag[i] = (addTag[i] + v) % MOD;
//}
//
//void down(int i, int ln, int rn) {
//    if (addTag[i] != 0) {
//        lazy(i << 1, addTag[i], ln);
//        lazy(i << 1 | 1, addTag[i], rn);
//        addTag[i] = 0;
//    }
//}
//
//void build(int l, int r, int i) {
//    if (l == r) {
//        sum[i] = arr[seg[l]] % MOD;
//    } else {
//        int mid = (l + r) / 2;
//        build(l, mid, i << 1);
//        build(mid + 1, r, i << 1 | 1);
//        up(i);
//    }
//}
//
//void add(int jobl, int jobr, int jobv, int l, int r, int i) {
//    if (jobl <= l && r <= jobr) {
//        lazy(i, jobv, r - l + 1);
//    } else {
//        int mid = (l + r) / 2;
//        down(i, mid - l + 1, r - mid);
//        if (jobl <= mid) {
//            add(jobl, jobr, jobv, l, mid, i << 1);
//        }
//        if (jobr > mid) {
//            add(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
//        }
//        up(i);
//    }
//}
//
//long long query(int jobl, int jobr, int l, int r, int i) {
//    if (jobl <= l && r <= jobr) {
//        return sum[i];
//    }
//    int mid = (l + r) / 2;
//    down(i, mid - l + 1, r - mid);
//    long long ans = 0;
//    if (jobl <= mid) {
//        ans = (ans + query(jobl, jobr, l, mid, i << 1)) % MOD;
//    }
//    if (jobr > mid) {
//        ans = (ans + query(jobl, jobr, mid + 1, r, i << 1 | 1)) % MOD;
//    }
//    return ans;
//}
//
//void pathAdd(int x, int y, int v) {
//    while (top[x] != top[y]) {
//        if (dep[top[x]] <= dep[top[y]]) {
//            add(dfn[top[y]], dfn[y], v, 1, n, 1);
//            y = fa[top[y]];
//        } else {
//            add(dfn[top[x]], dfn[x], v, 1, n, 1);
//            x = fa[top[x]];
//        }
//    }
//    add(min(dfn[x], dfn[y]), max(dfn[x], dfn[y]), v, 1, n, 1);
//}
//
//void subtreeAdd(int x, int v) {
//    add(dfn[x], dfn[x] + siz[x] - 1, v, 1, n, 1);
//}
//
//long long pathSum(int x, int y) {
//    long long ans = 0;
//    while (top[x] != top[y]) {
//        if (dep[top[x]] <= dep[top[y]]) {
//            ans = (ans + query(dfn[top[y]], dfn[y], 1, n, 1)) % MOD;
//            y = fa[top[y]];
//        } else {
//            ans = (ans + query(dfn[top[x]], dfn[x], 1, n, 1)) % MOD;
//            x = fa[top[x]];
//        }
//    }
//    ans = (ans + query(min(dfn[x], dfn[y]), max(dfn[x], dfn[y]), 1, n, 1)) % MOD;
//    return ans;
//}
//
//long long subtreeSum(int x) {
//    return query(dfn[x], dfn[x] + siz[x] - 1, 1, n, 1);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m >> root >> MOD;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1, u, v; i < n; i++) {
//        cin >> u >> v;
//        addEdge(u, v);
//        addEdge(v, u);
//    }
//    dfs1(root, 0);
//    dfs2(root, root);
//    build(1, n, 1);
//    for (int i = 1, op, x, y, v; i <= m; i++) {
//        cin >> op;
//        if (op == 1) {
//            cin >> x >> y >> v;
//            pathAdd(x, y, v);
//        } else if (op == 2) {
//            cin >> x >> y;
//            cout << pathSum(x, y) << "\n";
//        } else if (op == 3) {
//            cin >> x >> v;
//            subtreeAdd(x, v);
//        } else {
//            cin >> x;
//            cout << subtreeSum(x) << "\n";
//        }
//    }
//    return 0;
//}

package class162;

// 树上k级祖先，C++版
// 一共有n个节点，编号1~n，给定一个长度为n的数组arr，表示依赖关系
// 如果arr[i] = j，表示i号节点的父节点是j，如果arr[i] == 0，表示i号节点是树头
// 一共有m条查询，每条查询 x k : 打印x往上走k步的祖先节点编号
// 题目要求预处理的时间复杂度O(n * log n)，处理每条查询的时间复杂度O(1)
// 题目要求强制在线，必须按顺序处理每条查询，如何得到每条查询的入参，请打开测试链接查看
// 1 <= n <= 5 * 10^5
// 1 <= m <= 5 * 10^6
// 测试链接 : https://www.luogu.com.cn/problem/P5903
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//#define ui unsigned int
//
//using namespace std;
//
//const int MAXN = 500001;
//const int MAXH = 20;
//int n, m;
//ui s;
//int root;
//
//int head[MAXN];
//int nxt[MAXN];
//int to[MAXN];
//int cntg = 0;
//
//int stjump[MAXN][MAXH];
//int dep[MAXN];
//int len[MAXN];
//int son[MAXN];
//int top[MAXN];
//int dfn[MAXN];
//int cntd = 0;
//
//int high[MAXN];
//int up[MAXN];
//int down[MAXN];
//
//ui get(ui x) {
//    x ^= x << 13;
//    x ^= x >> 17;
//    x ^= x << 5;
//    s = x;
//    return x;
//}
//
//void setUp(int u, int i, int v) {
//    up[dfn[u] + i] = v;
//}
//
//int getUp(int u, int i) {
//    return up[dfn[u] + i];
//}
//
//void setDown(int u, int i, int v) {
//    down[dfn[u] + i] = v;
//}
//
//int getDown(int u, int i) {
//    return down[dfn[u] + i];
//}
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//void dfs1(int u, int f) {
//    stjump[u][0] = f;
//    for (int p = 1; p < MAXH; p++) {
//        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
//    }
//    dep[u] = dep[f] + 1;
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            dfs1(v, u);
//        }
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            if (son[u] == 0 || len[son[u]] < len[v]) {
//                son[u] = v;
//            }
//        }
//    }
//    len[u] = len[son[u]] + 1;
//}
//
//void dfs2(int u, int t) {
//    top[u] = t;
//    dfn[u] = ++cntd;
//    if (son[u] == 0) return;
//    dfs2(son[u], t);
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != stjump[u][0] && v != son[u]) {
//            dfs2(v, v);
//        }
//    }
//}
//
//void prepare() {
//    dfs1(root, 0);
//    dfs2(root, root);
//    high[0] = -1;
//    for (int i = 1; i <= n; i++) {
//        high[i] = high[i / 2] + 1;
//    }
//    for (int u = 1; u <= n; u++) {
//        if (top[u] == u) {
//            for (int i = 0, a = u, b = u; i < len[u]; i++, a = stjump[a][0], b = son[b]) {
//                setUp(u, i, a);
//                setDown(u, i, b);
//            }
//        }
//    }
//}
//
//int query(int x, int k) {
//    if (k == 0) {
//        return x;
//    }
//    if (k == (1 << high[k])) {
//        return stjump[x][high[k]];
//    }
//    x = stjump[x][high[k]];
//    k -= (1 << high[k]);
//    k -= dep[x] - dep[top[x]];
//    x = top[x];
//    return (k >= 0) ? getUp(x, k) : getDown(x, -k);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m >> s;
//    for (int i = 1, father; i <= n; i++) {
//        cin >> father;
//        if (father == 0) {
//            root = i;
//        } else {
//            addEdge(father, i);
//        }
//    }
//    prepare();
//    long long ans = 0;
//    for (int i = 1, x, k, lastAns = 0; i <= m; i++) {
//        x = (get(s) ^ lastAns) % n + 1;
//        k = (get(s) ^ lastAns) % dep[x];
//        lastAns = query(x, k);
//        ans ^= (long long) i * lastAns;
//    }
//    cout << ans << '\n';
//    return 0;
//}

package class162;

// 火热旅馆，C++版
// 一共有n个节点，给定n-1条边，所有节点连成一棵树
// 三个点构成一个点组(a, b, c)，打乱顺序认为是同一个点组
// 求树上有多少点组，内部任意两个节点之间的距离是一样的
// 1 <= n <= 10^5
// 答案一定在long类型范围内
// 测试链接 : https://www.luogu.com.cn/problem/P5904
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//int n;
//
//int head[MAXN];
//int nxt[MAXN << 1];
//int to[MAXN << 1];
//int cntg;
//
//int fa[MAXN];
//int son[MAXN];
//int len[MAXN];
//int cntd;
//
//int fid[MAXN];
//int gid[MAXN];
//long long f[MAXN];
//long long g[MAXN << 1];
//long long ans;
//
//void setf(int u, int i, long long v) {
//    f[fid[u] + i] = v;
//}
//
//long long getf(int u, int i) {
//    return f[fid[u] + i];
//}
//
//void setg(int u, int i, long long v) {
//    g[gid[u] + i] = v;
//}
//
//long long getg(int u, int i) {
//    return g[gid[u] + i];
//}
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//void dfs1(int u, int f) {
//    fa[u] = f;
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            dfs1(v, u);
//        }
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            if (son[u] == 0 || len[son[u]] < len[v]) {
//                son[u] = v;
//            }
//        }
//    }
//    len[u] = len[son[u]] + 1;
//}
//
//void dfs2(int u, int top) {
//    fid[u] = cntd++;
//    if (son[u] == 0) {
//        gid[u] = fid[top] * 2;
//        return;
//    }
//    dfs2(son[u], top);
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != son[u] && v != fa[u]) {
//            dfs2(v, v);
//        }
//    }
//    gid[u] = gid[son[u]] + 1;
//}
//
//void dfs3(int u) {
//    setf(u, 0, 1);
//    if (son[u] == 0) {
//        return;
//    }
//    dfs3(son[u]);
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != son[u] && v != fa[u]) {
//            dfs3(v);
//        }
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != son[u] && v != fa[u]) {
//            for (int i = 0; i <= len[v]; i++) {
//                if (i < len[u] && i - 1 >= 0) {
//                    ans += getg(u, i) * getf(v, i - 1);
//                }
//                if (i > 0 && i + 1 < len[v]) {
//                    ans += getf(u, i) * getg(v, i + 1);
//                }
//            }
//            for (int i = 0; i <= len[v]; i++) {
//                if (i + 1 < len[v]) {
//                    setg(u, i, getg(u, i) + getg(v, i + 1));
//                }
//                if (i - 1 >= 0) {
//                    setg(u, i, getg(u, i) + getf(u, i) * getf(v, i - 1));
//                }
//            }
//            for (int i = 0; i <= len[v]; i++) {
//                if (i - 1 >= 0) {
//                    setf(u, i, getf(u, i) + getf(v, i - 1));
//                }
//            }
//        }
//    }
//    ans += getg(u, 0);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1, u, v; i < n; i++) {
//        cin >> u >> v;
//        addEdge(u, v);
//        addEdge(v, u);
//    }
//    dfs1(1, 0);
//    dfs2(1, 1);
//    dfs3(1);
//    cout << ans << "\n";
//    return 0;
//}

package class163;

// 树上启发式合并模版题，C++版
// 一共有n个节点，编号1~n，给定n-1条边，所有节点连成一棵树，1号节点为树头
// 每个节点给定一种颜色值，一共有m条查询，每条查询给定参数x
// 每条查询打印x为头的子树上，一共有多少种不同的颜色
// 1 <= n、m、颜色值 <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/U41492
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//int n, m;
//int arr[MAXN];
//
//int head[MAXN];
//int nxt[MAXN << 1];
//int to[MAXN << 1];
//int cnt = 0;
//
//int fa[MAXN];
//int siz[MAXN];
//int son[MAXN];
//
//int colorCnt[MAXN];
//int ans[MAXN];
//int diffColors = 0;
//
//void addEdge(int u, int v) {
//    nxt[++cnt] = head[u];
//    to[cnt] = v;
//    head[u] = cnt;
//}
//
//void dfs1(int u, int f) {
//    fa[u] = f;
//    siz[u] = 1;
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            dfs1(v, u);
//        }
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != f) {
//            siz[u] += siz[v];
//            if (son[u] == 0 || siz[son[u]] < siz[v]) {
//                son[u] = v;
//            }
//        }
//    }
//}
//
//void effect(int u) {
//    if (++colorCnt[arr[u]] == 1) {
//        diffColors++;
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != fa[u]) {
//            effect(v);
//        }
//    }
//}
//
//void cancel(int u) {
//    colorCnt[arr[u]] = 0;
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != fa[u]) {
//            cancel(v);
//        }
//    }
//}
//
//void dfs2(int u, int keep) {
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != fa[u] && v != son[u]) {
//            dfs2(v, 0);
//        }
//    }
//    if (son[u] != 0) {
//        dfs2(son[u], 1);
//    }
//    if (++colorCnt[arr[u]] == 1) {
//        diffColors++;
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != fa[u] && v != son[u]) {
//            effect(v);
//        }
//    }
//    ans[u] = diffColors;
//    if (keep == 0) {
//        diffColors = 0;
//        cancel(u);
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1, u, v; i < n; i++) {
//        cin >> u >> v;
//        addEdge(u, v);
//        addEdge(v, u);
//    }
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    dfs1(1, 0);
//    dfs2(1, 0);
//    cin >> m;
//    for (int i = 1, cur; i <= m; i++) {
//        cin >> cur;
//        cout << ans[cur] << "\n";
//    }
//    return 0;
//}

package class163;

// 颜色平衡的子树，C++版
// 一共有n个节点，编号1~n，给定每个节点的颜色值和父亲节点编号
// 输入保证所有节点一定组成一棵树，并且1号节点是树头
// 如果一棵子树中，存在的每种颜色的节点个数都相同，这棵子树叫颜色平衡树
// 打印整棵树中有多少个子树是颜色平衡树
// 1 <= n、颜色值 <= 2 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P9233
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 200001;
//int n;
//int color[MAXN];
//int head[MAXN];
//int nxt[MAXN];
//int to[MAXN];
//int cnt = 0;
//int siz[MAXN];
//int son[MAXN];
//int colorCnt[MAXN];
//int colorNum[MAXN];
//int ans = 0;
//
//void addEdge(int u, int v) {
//    nxt[++cnt] = head[u];
//    to[cnt] = v;
//    head[u] = cnt;
//}
//
//void dfs1(int u) {
//    siz[u] = 1;
//    for (int e = head[u]; e > 0; e = nxt[e]) {
//        dfs1(to[e]);
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        siz[u] += siz[v];
//        if (son[u] == 0 || siz[son[u]] < siz[v]) {
//            son[u] = v;
//        }
//    }
//}
//
//void effect(int u) {
//    colorCnt[color[u]]++;
//    colorNum[colorCnt[color[u]] - 1]--;
//    colorNum[colorCnt[color[u]]]++;
//    for (int e = head[u]; e > 0; e = nxt[e]) {
//        effect(to[e]);
//    }
//}
//
//void cancel(int u) {
//    colorCnt[color[u]]--;
//    colorNum[colorCnt[color[u]] + 1]--;
//    colorNum[colorCnt[color[u]]]++;
//    for (int e = head[u]; e > 0; e = nxt[e]) {
//        cancel(to[e]);
//    }
//}
//
//void dfs2(int u, int keep) {
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != son[u]) {
//            dfs2(v, 0);
//        }
//    }
//    if (son[u] != 0) {
//        dfs2(son[u], 1);
//    }
//    colorCnt[color[u]]++;
//    colorNum[colorCnt[color[u]] - 1]--;
//    colorNum[colorCnt[color[u]]]++;
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != son[u]) {
//            effect(v);
//        }
//    }
//    if (colorCnt[color[u]] * colorNum[colorCnt[color[u]]] == siz[u]) {
//        ans++;
//    }
//    if (keep == 0) {
//        cancel(u);
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1, father; i <= n; i++) {
//        cin >> color[i] >> father;
//        if (i != 1) {
//            addEdge(father, i);
//        }
//    }
//    dfs1(1);
//    dfs2(1, 0);
//    cout << ans << "\n";
//    return 0;
//}


package class164;

// Kruskal重构树模版题，C++版
// 图里有n个点，m条无向边，每条边给定边权，图里可能有若干个连通的部分
// 一共有q条查询，每条查询都是如下的格式
// 查询 x y : 点x和点y希望连通起来，其中的最大边权希望尽量小，打印这个值
//            如果怎样都无法联通，打印"impossible"
// 1 <= n <= 10^5
// 1 <= m <= 3 * 10^5
// 1 <= q <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P2245
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Edge {
//    int u, v, w;
//};
//
//bool cmp(Edge x, Edge y) {
//    return x.w < y.w;
//}
//
//const int MAXK = 200001;
//const int MAXM = 300001;
//const int MAXH = 20;
//int n, m, q;
//Edge edge[MAXM];
//
//int father[MAXK];
//int head[MAXK];
//int nxt[MAXK];
//int to[MAXK];
//int cntg;
//int nodeKey[MAXK];
//int cntu;
//
//int dep[MAXK];
//int stjump[MAXK][MAXH];
//
//int find(int i) {
//    if (i != father[i]) {
//        father[i] = find(father[i]);
//    }
//    return father[i];
//}
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//void kruskalRebuild() {
//    for (int i = 1; i <= n; i++) {
//        father[i] = i;
//    }
//    sort(edge + 1, edge + m + 1, cmp);
//    cntu = n;
//    for (int i = 1; i <= m; i++) {
//        int fx = find(edge[i].u);
//        int fy = find(edge[i].v);
//        if (fx != fy) {
//            father[fx] = father[fy] = ++cntu;
//            father[cntu] = cntu;
//            nodeKey[cntu] = edge[i].w;
//            addEdge(cntu, fx);
//            addEdge(cntu, fy);
//        }
//    }
//}
//
//void dfs(int u, int fa) {
//    dep[u] = dep[fa] + 1;
//    stjump[u][0] = fa;
//    for (int p = 1; p < MAXH; p++) {
//        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
//    }
//    for (int e = head[u]; e > 0; e = nxt[e]) {
//        dfs(to[e], u);
//    }
//}
//
//int lca(int a, int b) {
//    if (dep[a] < dep[b]) {
//        int tmp = a;
//        a = b;
//        b = tmp;
//    }
//    for (int p = MAXH - 1; p >= 0; p--) {
//        if (dep[stjump[a][p]] >= dep[b]) {
//            a = stjump[a][p];
//        }
//    }
//    if (a == b) {
//        return a;
//    }
//    for (int p = MAXH - 1; p >= 0; p--) {
//        if (stjump[a][p] != stjump[b][p]) {
//            a = stjump[a][p];
//            b = stjump[b][p];
//        }
//    }
//    return stjump[a][0];
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= m; i++) {
//        cin >> edge[i].u >> edge[i].v >> edge[i].w;
//    }
//    kruskalRebuild();
//    for (int i = 1; i <= cntu; i++) {
//        if (i == father[i]) {
//            dfs(i, 0);
//        }
//    }
//    cin >> q;
//    for (int i = 1, x, y; i <= q; i++) {
//        cin >> x >> y;
//        if (find(x) != find(y)) {
//            cout << "impossible" << "\n";
//        } else {
//            cout << nodeKey[lca(x, y)] << "\n";
//        }
//    }
//    return 0;
//}

package class164;

// youyou的军训，C++版
// 图里有n个点，m条无向边，每条边给定不同的边权，图里可能有若干个连通的部分
// 一开始limit = 0，接下来有q条操作，每种操作的格式如下
// 操作 1 x   : 所有修改操作生效，然后limit设置成x
// 操作 2 x   : 从点x出发，只能走 边权 >= limit 的边，查询最多到达几个点
// 操作 3 x y : 第x条边的边权修改为y，不是立刻生效，等到下次操作1发生时生效
// 题目保证边权不管如何修改，所有边权都不相等，并且每条边的边权排名不发生变化
// 1 <= n、m、q <= 4 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P9638
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Edge {
//    int u, v, w, i;
//};
//
//bool cmp(Edge x, Edge y) {
//    return x.w > y.w;
//}
//
//const int MAXK = 800001;
//const int MAXM = 400001;
//const int MAXH = 20;
//int n, m, q;
//
//Edge edge[MAXM];
//int edgeToTree[MAXM];
//
//int pendEdge[MAXM];
//int pendVal[MAXM];
//int cntp;
//
//int father[MAXK];
//
//int head[MAXK];
//int nxt[MAXK];
//int to[MAXK];
//int cntg;
//int nodeKey[MAXK];
//int cntu;
//
//int leafsiz[MAXK];
//int stjump[MAXK][MAXH];
//
//int find(int i) {
//    if (i != father[i]) {
//        father[i] = find(father[i]);
//    }
//    return father[i];
//}
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//void kruskalRebuild() {
//    for (int i = 1; i <= n; i++) {
//        father[i] = i;
//    }
//    sort(edge + 1, edge + m + 1, cmp);
//    cntu = n;
//    for (int i = 1, fx, fy; i <= m; i++) {
//        fx = find(edge[i].u);
//        fy = find(edge[i].v);
//        if (fx != fy) {
//            father[fx] = father[fy] = ++cntu;
//            father[cntu] = cntu;
//            nodeKey[cntu] = edge[i].w;
//            addEdge(cntu, fx);
//            addEdge(cntu, fy);
//            edgeToTree[edge[i].i] = cntu;
//        }
//    }
//}
//
//void dfs(int u, int fa) {
//    stjump[u][0] = fa;
//    for (int p = 1; p < MAXH; p++) {
//        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
//    }
//    for (int e = head[u]; e > 0; e = nxt[e]) {
//        dfs(to[e], u);
//    }
//    if (u <= n) {
//        leafsiz[u] = 1;
//    } else {
//        leafsiz[u] = 0;
//    }
//    for (int e = head[u]; e > 0; e = nxt[e]) {
//        leafsiz[u] += leafsiz[to[e]];
//    }
//}
//
//int query(int u, int limit) {
//    for (int p = MAXH - 1; p >= 0; p--) {
//        if (stjump[u][p] > 0 && nodeKey[stjump[u][p]] >= limit) {
//            u = stjump[u][p];
//        }
//    }
//    return leafsiz[u];
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m >> q;
//    for (int i = 1; i <= m; i++) {
//        cin >> edge[i].u >> edge[i].v >> edge[i].w;
//        edge[i].i = i;
//    }
//    kruskalRebuild();
//    for (int i = 1; i <= cntu; i++) {
//        if (i == father[i]) {
//            dfs(i, 0);
//        }
//    }
//    int op, x, y, limit = 0;
//    for (int i = 1; i <= q; i++) {
//        cin >> op;
//        if (op == 1) {
//            for (int k = 1; k <= cntp; k++) {
//                nodeKey[edgeToTree[pendEdge[k]]] = pendVal[k];
//            }
//            cntp = 0;
//            cin >> limit;
//        } else if (op == 2) {
//            cin >> x;
//            cout << query(x, limit) << "\n";
//        } else {
//            cin >> x >> y;
//            if (edgeToTree[x] != 0) {
//                pendEdge[++cntp] = x;
//                pendVal[cntp] = y;
//            }
//        }
//    }
//    return 0;
//}

package class166;

// 线段树分治模版题，C++版
// 一共有n个节点，一共有m条操作，每条操作是如下三种类型中的一种
// 操作 0 x y : 点x和点y之间一定没有边，现在增加一条边
// 操作 1 x y : 点x和点y之间一定存在边，现在删除这条边
// 操作 2 x y : 查询点x和点y是否联通
// 1 <= n <= 5000
// 1 <= m <= 500000
// 不强制在线，可以离线处理
// 测试链接 : https://loj.ac/p/121
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 5001;
//const int MAXM = 500001;
//const int MAXT = 5000001;
//
//int n, m;
//
//int op[MAXM];
//int u[MAXM];
//int v[MAXM];
//
//int last[MAXN][MAXN];
//
//int father[MAXN];
//int siz[MAXN];
//int rollback[MAXN][2];
//int opsize = 0;
//
//int head[MAXM << 2];
//int nxt[MAXT];
//int tox[MAXT];
//int toy[MAXT];
//int cnt = 0;
//
//bool ans[MAXM];
//
//void addEdge(int i, int x, int y) {
//    nxt[++cnt] = head[i];
//    tox[cnt] = x;
//    toy[cnt] = y;
//    head[i] = cnt;
//}
//
//int find(int i) {
//    while (i != father[i]) {
//        i = father[i];
//    }
//    return i;
//}
//
//void Union(int x, int y) {
//    int fx = find(x);
//    int fy = find(y);
//    if (siz[fx] < siz[fy]) {
//        int tmp = fx;
//        fx = fy;
//        fy = tmp;
//    }
//    father[fy] = fx;
//    siz[fx] += siz[fy];
//    rollback[++opsize][0] = fx;
//    rollback[opsize][1] = fy;
//}
//
//void undo() {
//    int fx = rollback[opsize][0];
//    int fy = rollback[opsize--][1];
//    father[fy] = fy;
//    siz[fx] -= siz[fy];
//}
//
//void add(int jobl, int jobr, int jobx, int joby, int l, int r, int i) {
//    if (jobl <= l && r <= jobr) {
//        addEdge(i, jobx, joby);
//    } else {
//        int mid = (l + r) >> 1;
//        if (jobl <= mid) {
//            add(jobl, jobr, jobx, joby, l, mid, i << 1);
//        }
//        if (jobr > mid) {
//            add(jobl, jobr, jobx, joby, mid + 1, r, i << 1 | 1);
//        }
//    }
//}
//
//void dfs(int l, int r, int i) {
//    int unionCnt = 0;
//    for (int ei = head[i], x, y, fx, fy; ei > 0; ei = nxt[ei]) {
//        x = tox[ei];
//        y = toy[ei];
//        fx = find(x);
//        fy = find(y);
//        if (fx != fy) {
//            Union(fx, fy);
//            unionCnt++;
//        }
//    }
//    if (l == r) {
//        if (op[l] == 2) {
//            ans[l] = find(u[l]) == find(v[l]);
//        }
//    } else {
//        int mid = (l + r) >> 1;
//        dfs(l, mid, i << 1);
//        dfs(mid + 1, r, i << 1 | 1);
//    }
//    for (int j = 1; j <= unionCnt; j++) {
//        undo();
//    }
//}
//
//void prepare() {
//    for (int i = 1; i <= n; i++) {
//        father[i] = i;
//        siz[i] = 1;
//    }
//    for (int i = 1, t, x, y; i <= m; i++) {
//        t = op[i];
//        x = u[i];
//        y = v[i];
//        if (t == 0) {
//            last[x][y] = i;
//        } else if (t == 1) {
//            add(last[x][y], i - 1, x, y, 1, m, 1);
//            last[x][y] = 0;
//        }
//    }
//    for (int x = 1; x <= n; x++) {
//        for (int y = x + 1; y <= n; y++) {
//            if (last[x][y] != 0) {
//                add(last[x][y], m, x, y, 1, m, 1);
//            }
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1, t, x, y; i <= m; i++) {
//        cin >> t >> x >> y;
//        op[i] = t;
//        u[i] = min(x, y);
//        v[i] = max(x, y);
//    }
//    prepare();
//    dfs(1, m, 1);
//    for (int i = 1; i <= m; i++) {
//        if (op[i] == 2) {
//            if (ans[i]) {
//                cout << "Y" << "\n";
//            } else {
//                cout << "N" << "\n";
//            }
//        }
//    }
//    return 0;
//}

package class166;

// 判断二分图，C++版
// 一共有n个节点，时刻的范围0~k，一共有m条操作，每条操作含义如下
// 操作 x y l r : 点x到点y之间连一条边，该边在l时刻出现，在r时刻消失
// 分别打印1时刻以内、2时刻以内..k时刻以内，图是不是二分图
// 注意i时刻以内是0~i-1时间段的意思
// 1 <= n、k <= 10^5    1 <= m <= 2 * 10^5
// 1 <= x、y <= n       0 <= l、r <= k
// 测试链接 : https://www.luogu.com.cn/problem/P5787
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//const int MAXT = 3000001;
//int n, m, k;
//
//int father[MAXN << 1];
//int siz[MAXN << 1];
//int rollback[MAXN << 1][2];
//int opsize = 0;
//
//int head[MAXN << 2];
//int nxt[MAXT];
//int tox[MAXT];
//int toy[MAXT];
//int cnt = 0;
//
//bool ans[MAXN];
//
//void addEdge(int i, int x, int y) {
//    nxt[++cnt] = head[i];
//    tox[cnt] = x;
//    toy[cnt] = y;
//    head[i] = cnt;
//}
//
//int find(int i) {
//    while (i != father[i]) {
//        i = father[i];
//    }
//    return i;
//}
//
//void Union(int x, int y) {
//    int fx = find(x);
//    int fy = find(y);
//    if (siz[fx] < siz[fy]) {
//        int tmp = fx;
//        fx = fy;
//        fy = tmp;
//    }
//    father[fy] = fx;
//    siz[fx] += siz[fy];
//    rollback[++opsize][0] = fx;
//    rollback[opsize][1] = fy;
//}
//
//void undo() {
//    int fx = rollback[opsize][0];
//    int fy = rollback[opsize--][1];
//    father[fy] = fy;
//    siz[fx] -= siz[fy];
//}
//
//void add(int jobl, int jobr, int jobx, int joby, int l, int r, int i) {
//    if (jobl <= l && r <= jobr) {
//        addEdge(i, jobx, joby);
//    } else {
//        int mid = (l + r) >> 1;
//        if (jobl <= mid) {
//            add(jobl, jobr, jobx, joby, l, mid, i << 1);
//        }
//        if (jobr > mid) {
//            add(jobl, jobr, jobx, joby, mid + 1, r, i << 1 | 1);
//        }
//    }
//}
//
//void dfs(int l, int r, int i) {
//    bool check = true;
//    int unionCnt = 0;
//    for (int ei = head[i]; ei > 0; ei = nxt[ei]) {
//        int x = tox[ei], y = toy[ei], fx = find(x), fy = find(y);
//        if (fx == fy) {
//            check = false;
//            break;
//        } else {
//            Union(x, y + n);
//            Union(y, x + n);
//            unionCnt += 2;
//        }
//    }
//    if (check) {
//        if (l == r) {
//            ans[l] = true;
//        } else {
//            int mid = (l + r) >> 1;
//            dfs(l, mid, i << 1);
//            dfs(mid + 1, r, i << 1 | 1);
//        }
//    } else {
//        for (int k = l; k <= r; k++) {
//            ans[k] = false;
//        }
//    }
//    for (int k = 1; k <= unionCnt; k++) {
//        undo();
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m >> k;
//    for (int i = 1; i <= n * 2; i++) {
//        father[i] = i;
//        siz[i] = 1;
//    }
//    for (int i = 1, x, y, l, r; i <= m; i++) {
//        cin >> x >> y >> l >> r;
//        add(l + 1, r, x, y, 1, k, 1);
//    }
//    dfs(1, k, 1);
//    for (int i = 1; i <= k; i++) {
//        if (ans[i]) {
//            cout << "Yes" << "\n";
//        } else {
//            cout << "No" << "\n";
//        }
//    }
//    return 0;
//}

package class168;

// 区间内第k小，第二种写法，C++版
// 给定一个长度为n的数组，接下来有m条查询，格式如下
// 查询 l r k : 打印[l..r]范围内第k小的值
// 1 <= n、m <= 2 * 10^5
// 1 <= 数组中的数字 <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/P3834
// 本题是讲解157，可持久化线段树模版题，现在作为整体二分的模版题
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Number {
//    int i, v;
//};
//
//bool NumberCmp(Number x, Number y) {
//    return x.v < y.v;
//}
//
//const int MAXN = 200001;
//int n, m;
//
//Number arr[MAXN];
//
//int qid[MAXN];
//int l[MAXN];
//int r[MAXN];
//int k[MAXN];
//
//int tree[MAXN];
//int used = 0;
//
//int lset[MAXN];
//int rset[MAXN];
//
//int ans[MAXN];
//
//int lowbit(int i) {
//    return i & -i;
//}
//
//void add(int i, int v) {
//    while (i <= n) {
//        tree[i] += v;
//        i += lowbit(i);
//    }
//}
//
//int sum(int i) {
//    int ret = 0;
//    while (i > 0) {
//        ret += tree[i];
//        i -= lowbit(i);
//    }
//    return ret;
//}
//
//int query(int l, int r) {
//    return sum(r) - sum(l - 1);
//}
//
//void compute(int ql, int qr, int vl, int vr) {
//    if (ql > qr) {
//        return;
//    }
//    if (vl == vr) {
//        for (int i = ql; i <= qr; i++) {
//            ans[qid[i]] = arr[vl].v;
//        }
//    } else {
//        int mid = (vl + vr) / 2;
//        while (used < mid) {
//            used++;
//            add(arr[used].i, 1);
//        }
//        while (used > mid) {
//            add(arr[used].i, -1);
//            used--;
//        }
//        int lsiz = 0, rsiz = 0;
//        for (int i = ql; i <= qr; i++) {
//            int id = qid[i];
//            int satisfy = query(l[id], r[id]);
//            if (satisfy >= k[id]) {
//                lset[++lsiz] = id;
//            } else {
//                rset[++rsiz] = id;
//            }
//        }
//        for (int i = 1; i <= lsiz; i++) {
//            qid[ql + i - 1] = lset[i];
//        }
//        for (int i = 1; i <= rsiz; i++) {
//            qid[ql + lsiz + i - 1] = rset[i];
//        }
//        compute(ql, ql + lsiz - 1, vl, mid);
//        compute(ql + lsiz, qr, mid + 1, vr);
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        arr[i].i = i;
//        cin >> arr[i].v;
//    }
//    for (int i = 1; i <= m; i++) {
//        qid[i] = i;
//        cin >> l[i] >> r[i] >> k[i];
//    }
//    sort(arr + 1, arr + n + 1, NumberCmp);
//    compute(1, m, 1, n);
//    for (int i = 1; i <= m; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class170;

// 三维偏序，C++版
// 一共有n个对象，属性值范围[1, k]，每个对象有a属性、b属性、c属性
// f(i)表示，aj <= ai 且 bj <= bi 且 cj <= ci 且 j != i 的j的数量
// ans(d)表示，f(i) == d 的i的数量
// 打印所有的ans[d]，d的范围[0, n)
// 1 <= n <= 10^5
// 1 <= k <= 2 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P3810
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Node {
//    int i, a, b, c;
//};
//
//bool CmpAbc(Node x, Node y) {
//    if (x.a != y.a) {
//        return x.a < y.a;
//    }
//    if (x.b != y.b) {
//        return x.b < y.b;
//    }
//    return x.c < y.c;
//}
//
//bool CmpB(Node x, Node y) {
//    return x.b < y.b;
//}
//
//const int MAXN = 100001;
//const int MAXK = 200001;
//int n, k;
//
//Node arr[MAXN];
//int tree[MAXK];
//int f[MAXN];
//int ans[MAXN];
//
//int lowbit(int i) {
//    return i & -i;
//}
//
//void add(int i, int v) {
//    while (i <= k) {
//        tree[i] += v;
//        i += lowbit(i);
//    }
//}
//
//int query(int i) {
//    int ret = 0;
//    while (i > 0) {
//        ret += tree[i];
//        i -= lowbit(i);
//    }
//    return ret;
//}
//
//void merge(int l, int m, int r) {
//    int p1, p2;
//    for (p1 = l - 1, p2 = m + 1; p2 <= r; p2++) {
//        while (p1 + 1 <= m && arr[p1 + 1].b <= arr[p2].b) {
//            p1++;
//            add(arr[p1].c, 1);
//        }
//        f[arr[p2].i] += query(arr[p2].c);
//    }
//    for (int i = l; i <= p1; i++) {
//        add(arr[i].c, -1);
//    }
//    sort(arr + l, arr + r + 1, CmpB);
//}
//
//void cdq(int l, int r) {
//    if (l == r) {
//        return;
//    }
//    int mid = (l + r) / 2;
//    cdq(l, mid);
//    cdq(mid + 1, r);
//    merge(l, mid, r);
//}
//
//void prepare() {
//    sort(arr + 1, arr + n + 1, CmpAbc);
//    for (int l = 1, r = 1; l <= n; l = ++r) {
//        while (r + 1 <= n && arr[l].a == arr[r + 1].a && arr[l].b == arr[r + 1].b && arr[l].c == arr[r + 1].c) {
//            r++;
//        }
//        for (int i = l; i <= r; i++) {
//            f[arr[i].i] = r - i;
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> k;
//    for (int i = 1; i <= n; i++) {
//        arr[i].i = i;
//        cin >> arr[i].a >> arr[i].b >> arr[i].c;
//    }
//    prepare();
//    cdq(1, n);
//    for (int i = 1; i <= n; i++) {
//        ans[f[i]]++;
//    }
//    for (int i = 0; i < n; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class171;

// 德丽莎世界第一可爱，C++版
// 一共有n个怪兽，每个怪兽有a、b、c、d四个能力值，以及打败之后的收益v
// 可以选择任意顺序打怪兽，每次打的怪兽的四种能力值都不能小于上次打的怪兽
// 打印能获得的最大收益，可能所有怪兽收益都是负数，那也需要至少打一只怪兽
// 1 <= n <= 5 * 10^4
// -10^5 <= a、b、c、d <= +10^5
// -10^9 <= v <= +10^9
// 测试链接 : https://www.luogu.com.cn/problem/P5621
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Node {
//    int a, b, c, d;
//    long long v;
//    int i;
//    bool left;
//};
//
//bool Cmp1(Node x, Node y) {
//    if (x.a != y.a) return x.a < y.a;
//    if (x.b != y.b) return x.b < y.b;
//    if (x.c != y.c) return x.c < y.c;
//    if (x.d != y.d) return x.d < y.d;
//    return x.v > y.v;
//}
//
//bool Cmp2(Node x, Node y) {
//    if (x.b != y.b) return x.b < y.b;
//    return x.i < y.i;
//}
//
//bool Cmp3(Node x, Node y) {
//    if (x.c != y.c) return x.c < y.c;
//    return x.i < y.i;
//}
//
//const int MAXN = 50001;
//const long long INF = 1e18 + 1;
//int n, s;
//
//Node arr[MAXN];
//int sortd[MAXN];
//
//Node tmp1[MAXN];
//Node tmp2[MAXN];
//long long tree[MAXN];
//long long dp[MAXN];
//
//int lowbit(int i) {
//    return i & -i;
//}
//
//void more(int i, long long num) {
//    while (i <= s) {
//        tree[i] = max(tree[i], num);
//        i += lowbit(i);
//    }
//}
//
//long long query(int i) {
//    long long ret = -INF;
//    while (i > 0) {
//        ret = max(ret, tree[i]);
//        i -= lowbit(i);
//    }
//    return ret;
//}
//
//void clear(int i) {
//    while (i <= s) {
//        tree[i] = -INF;
//        i += lowbit(i);
//    }
//}
//
//void merge(int l, int m, int r) {
//    for (int i = l; i <= r; i++) {
//        tmp2[i] = tmp1[i];
//    }
//    sort(tmp2 + l, tmp2 + m + 1, Cmp3);
//    sort(tmp2 + m + 1, tmp2 + r + 1, Cmp3);
//    int p1, p2;
//    for (p1 = l - 1, p2 = m + 1; p2 <= r; p2++) {
//        while (p1 + 1 <= m && tmp2[p1 + 1].c <= tmp2[p2].c) {
//            p1++;
//            if (tmp2[p1].left) {
//                more(tmp2[p1].d, dp[tmp2[p1].i]);
//            }
//        }
//        if (!tmp2[p2].left) {
//            dp[tmp2[p2].i] = max(dp[tmp2[p2].i], query(tmp2[p2].d) + tmp2[p2].v);
//        }
//    }
//    for (int i = l; i <= p1; i++) {
//        if (tmp2[i].left) {
//            clear(tmp2[i].d);
//        }
//    }
//}
//
//void cdq2(int l, int r) {
//    if (l == r) return;
//    int mid = (l + r) / 2;
//    cdq2(l, mid);
//    merge(l, mid, r);
//    cdq2(mid + 1, r);
//}
//
//void cdq1(int l, int r) {
//    if (l == r) return;
//    int mid = (l + r) / 2;
//    cdq1(l, mid);
//    for (int i = l; i <= r; i++) {
//        tmp1[i] = arr[i];
//        tmp1[i].left = i <= mid;
//    } 
//    sort(tmp1 + l, tmp1 + r + 1, Cmp2);
//    cdq2(l, r);
//    cdq1(mid + 1, r);
//}
//
//int lower(long long num) {
//    int l = 1, r = s, ans = 1;
//    while (l <= r) {
//        int m = (l + r) / 2;
//        if (sortd[m] >= num) {
//            ans = m;
//            r = m - 1;
//        } else {
//            l = m + 1;
//        }
//    }
//    return ans;
//}
//
//void prepare() {
//    for (int i = 1; i <= n; i++) {
//        sortd[i] = arr[i].d;
//    }
//    sort(sortd + 1, sortd + n + 1);
//    s = 1;
//    for (int i = 2; i <= n; i++) {
//        if (sortd[s] != sortd[i]) {
//            sortd[++s] = sortd[i];
//        }
//    }
//    for (int i = 1; i <= n; i++) {
//        arr[i].d = lower(arr[i].d);
//    }
//    sort(arr + 1, arr + n + 1, Cmp1);
//    int m = 1;
//    for (int i = 2; i <= n; i++) {
//        if (arr[m].a == arr[i].a && arr[m].b == arr[i].b &&
//            arr[m].c == arr[i].c && arr[m].d == arr[i].d) {
//            if (arr[i].v > 0) {
//                arr[m].v += arr[i].v;
//            }
//        } else {
//            arr[++m] = arr[i];
//        }
//    }
//    n = m;
//    for (int i = 1; i <= n; i++) {
//        arr[i].i = i;
//        dp[i] = arr[i].v;
//    }
//    for (int i = 1; i <= s; i++) {
//        tree[i] = -INF;
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i].a >> arr[i].b >> arr[i].c >> arr[i].d >> arr[i].v;
//    }
//    prepare();
//    cdq1(1, n);
//    long long ans = -INF;
//    for (int i = 1; i <= n; i++) {
//        ans = max(ans, dp[i]);
//    }
//    cout << ans << '\n';
//    return 0;
//}

package class172;

// Give Away，C++版
// 给定一个长度为n的数组arr，接下来有m条操作，每条操作是如下两种类型中的一种
// 操作 0 a b c : 打印arr[a..b]范围上>=c的数字个数
// 操作 1 a b   : 把arr[a]的值改成b
// 1 <= n <= 5 * 10^5
// 1 <= m <= 10^5
// 1 <= 数组中的值 <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/SP18185
// 测试链接 : https://www.spoj.com/problems/GIVEAWAY
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 500001;
//const int MAXB = 1001;
//int n, m;
//int arr[MAXN];
//int sortv[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//
//void build() {
//    blen = (int)sqrt(n);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, n);
//    }
//    for (int i = 1; i <= n; i++) {
//        sortv[i] = arr[i];
//    }
//    for (int i = 1; i <= bnum; i++) {
//        sort(sortv + bl[i], sortv + br[i] + 1);
//    }
//}
//
//int getCnt(int i, int v) {
//    int l = bl[i], r = br[i], m, ans = 0;
//    while (l <= r) {
//        m = (l + r) >> 1;
//        if (sortv[m] >= v) {
//            ans += r - m + 1;
//            r = m - 1;
//        } else {
//            l = m + 1;
//        }
//    }
//    return ans;
//}
//
//int query(int l, int r, int v) {
//    int ans = 0;
//    if (bi[l] == bi[r]) {
//        for (int i = l; i <= r; i++) {
//            if (arr[i] >= v) {
//                ans++;
//            }
//        }
//    } else {
//        for (int i = l; i <= br[bi[l]]; i++) {
//            if (arr[i] >= v) {
//                ans++;
//            }
//        }
//        for (int i = bl[bi[r]]; i <= r; i++) {
//            if (arr[i] >= v) {
//                ans++;
//            }
//        }
//        for (int i = bi[l] + 1; i <= bi[r] - 1; i++) {
//            ans += getCnt(i, v);
//        }
//    }
//    return ans;
//}
//
//void update(int i, int v) {
//    int l = bl[bi[i]];
//    int r = br[bi[i]];
//    arr[i] = v;
//    for (int j = l; j <= r; j++) {
//        sortv[j] = arr[j];
//    }
//    sort(sortv + l, sortv + r + 1);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    build();
//    cin >> m;
//    int op, a, b, c;
//    for (int i = 1; i <= m; i++) {
//        cin >> op >> a >> b;
//        if (op == 0) {
//            cin >> c;
//            cout << query(a, b, c) << '\n';
//        } else {
//            update(a, b);
//        }
//    }
//    return 0;
//}

package class172;

// 空间少求众数的次数，C++版
// 给定一个长度为n的数组arr，接下来有m条操作，每条操作格式如下
// 操作 l r : 打印arr[l..r]范围上，众数到底出现了几次
// 1 <= 所有数值 <= 5 * 10^5
// 内存空间只有64MB，题目要求强制在线，具体规则可以打开测试链接查看
// 测试链接 : https://www.luogu.com.cn/problem/P5048
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Node {
//    int v, i;
//};
//
//bool NodeCmp(Node a, Node b) {
//    if (a.v != b.v) {
//        return a.v < b.v;
//    }
//    return a.i < b.i;
//}
//
//const int MAXN = 500001;
//const int MAXB = 801;
//int n, m;
//int arr[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//
//Node sortList[MAXN];
//int listIdx[MAXN];
//
//int modeCnt[MAXB][MAXB];
//int numCnt[MAXN];
//
//void prepare() {
//    blen = (int)sqrt(n);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, n);
//    }
//    for (int i = 1; i <= n; i++) {
//        sortList[i].v = arr[i];
//        sortList[i].i = i;
//    }
//    sort(sortList + 1, sortList + n + 1, NodeCmp);
//    for (int i = 1; i <= n; i++) {
//        listIdx[sortList[i].i] = i;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        for (int j = i; j <= bnum; j++) {
//            int cnt = modeCnt[i][j - 1];
//            for (int k = bl[j]; k <= br[j]; k++) {
//                cnt = max(cnt, ++numCnt[arr[k]]);
//            }
//            modeCnt[i][j] = cnt;
//        }
//        for (int j = 1; j <= n; j++) {
//            numCnt[j] = 0;
//        }
//    }
//}
//
//int query(int l, int r) {
//    int ans = 0;
//    if (bi[l] == bi[r]) {
//        for (int i = l; i <= r; i++) {
//            ans = max(ans, ++numCnt[arr[i]]);
//        }
//        for (int i = l; i <= r; i++) {
//            numCnt[arr[i]] = 0;
//        }
//    } else {
//        ans = modeCnt[bi[l] + 1][bi[r] - 1];
//        for (int i = l, idx; i <= br[bi[l]]; i++) {
//            idx = listIdx[i];
//            while (idx + ans <= n && sortList[idx + ans].v == arr[i] && sortList[idx + ans].i <= r) {
//                ans++;
//            }
//        }
//        for (int i = bl[bi[r]], idx; i <= r; i++) {
//            idx = listIdx[i];
//            while (idx - ans >= 1 && sortList[idx - ans].v == arr[i] && sortList[idx - ans].i >= l) {
//                ans++;
//            }
//        }
//    }
//    return ans;
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    for (int i = 1, l, r, lastAns = 0; i <= m; i++) {
//        cin >> l >> r;
//        l ^= lastAns;
//        r ^= lastAns;
//        lastAns = query(l, r);
//        cout << lastAns << '\n';
//    }
//    return 0;
//}

package class173;

// 由乃打扑克，C++版
// 给定一个长度为n的数组arr，接下来有m条操作，操作类型如下
// 操作 1 l r v : 查询arr[l..r]范围上，第v小的数
// 操作 2 l r v : arr[l..r]范围上每个数加v，v可能是负数
// 1 <= n、m <= 10^5
// -2 * 10^4 <= 数组中的值 <= +2 * 10^4
// 测试链接 : https://www.luogu.com.cn/problem/P5356
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//const int MAXB = 1001;
//
//int n, m;
//int arr[MAXN];
//int sortv[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//int lazy[MAXB];
//
//void innerAdd(int l, int r, int v) {
//    for (int i = l; i <= r; i++) {
//        arr[i] += v;
//    }
//    for (int i = bl[bi[l]]; i <= br[bi[l]]; i++) {
//        sortv[i] = arr[i];
//    }
//    sort(sortv + bl[bi[l]], sortv + br[bi[l]] + 1);
//}
//
//void add(int l, int r, int v) {
//    if (bi[l] == bi[r]) {
//        innerAdd(l, r, v);
//    } else {
//        innerAdd(l, br[bi[l]], v);
//        innerAdd(bl[bi[r]], r, v);
//        for (int i = bi[l] + 1; i <= bi[r] - 1; i++) {
//            lazy[i] += v;
//        }
//    }
//}
//
//int getMin(int l, int r) {
//    int lb = bi[l], rb = bi[r], ans = 10000000;
//    if (lb == rb) {
//        for (int i = l; i <= r; i++) {
//            ans = min(ans, arr[i] + lazy[lb]);
//        }
//    } else {
//        for (int i = l; i <= br[lb]; i++) {
//            ans = min(ans, arr[i] + lazy[lb]);
//        }
//        for (int i = bl[rb]; i <= r; i++) {
//            ans = min(ans, arr[i] + lazy[rb]);
//        }
//        for (int i = lb + 1; i <= rb - 1; i++) {
//            ans = min(ans, sortv[bl[i]] + lazy[i]);
//        }
//    }
//    return ans;
//}
//
//int getMax(int l, int r) {
//    int lb = bi[l], rb = bi[r], ans = -10000000;
//    if (lb == rb) {
//        for (int i = l; i <= r; i++) {
//            ans = max(ans, arr[i] + lazy[lb]);
//        }
//    } else {
//        for (int i = l; i <= br[lb]; i++) {
//            ans = max(ans, arr[i] + lazy[lb]);
//        }
//        for (int i = bl[rb]; i <= r; i++) {
//            ans = max(ans, arr[i] + lazy[rb]);
//        }
//        for (int i = lb + 1; i <= rb - 1; i++) {
//            ans = max(ans, sortv[br[i]] + lazy[i]);
//        }
//    }
//    return ans;
//}
//
//int blockCnt(int i, int v) {
//    v -= lazy[i];
//    int l = bl[i], r = br[i];
//    if (sortv[l] > v) {
//        return 0;
//    }
//    if (sortv[r] <= v) {
//        return r - l + 1;
//    }
//    int find = l;
//    while (l <= r) {
//        int m = (l + r) >> 1;
//        if (sortv[m] <= v) {
//            find = m;
//            l = m + 1;
//        } else {
//            r = m - 1;
//        }
//    }
//    return find - bl[i] + 1;
//}
//
//int getCnt(int l, int r, int v) {
//    int lb = bi[l], rb = bi[r], ans = 0;
//    if (lb == rb) {
//        for (int i = l; i <= r; i++) {
//            if (arr[i] + lazy[lb] <= v) {
//                ans++;
//            }
//        }
//    } else {
//        for (int i = l; i <= br[lb]; i++) {
//            if (arr[i] + lazy[lb] <= v) {
//                ans++;
//            }
//        }
//        for (int i = bl[rb]; i <= r; i++) {
//            if (arr[i] + lazy[rb] <= v) {
//                ans++;
//            }
//        }
//        for (int i = lb + 1; i <= rb - 1; i++) {
//            ans += blockCnt(i, v);
//        }
//    }
//    return ans;
//}
//
//int query(int l, int r, int k) {
//    if (k < 1 || k > r - l + 1) {
//        return -1;
//    }
//    int minv = getMin(l, r);
//    int maxv = getMax(l, r);
//    int ans = -1;
//    while (minv <= maxv) {
//        int midv = minv + (maxv - minv) / 2;
//        if (getCnt(l, r, midv) >= k) {
//            ans = midv;
//            maxv = midv - 1;
//        } else {
//            minv = midv + 1;
//        }
//    }
//    return ans;
//}
//
//void prepare() {
//    blen = (int)sqrt(n / 2);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, n);
//    }
//    for (int i = 1; i <= n; i++) {
//        sortv[i] = arr[i];
//    }
//    for (int i = 1; i <= bnum; i++) {
//        sort(sortv + bl[i], sortv + br[i] + 1);
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    for (int i = 1, op, l, r, v; i <= m; i++) {
//        cin >> op >> l >> r >> v;
//        if (op == 1) {
//            cout << query(l, r, v) << '\n';
//        } else {
//            add(l, r, v);
//        }
//    }
//    return 0;
//}

package class173;

// 序列，C++版
// 给定一个长度为n的数组arr，初始时刻认为是第0秒
// 接下来发生m条操作，第i条操作发生在第i秒，操作类型如下
// 操作 1 l r v : arr[l..r]范围上每个数加v，v可能是负数
// 操作 2 x v   : 不包括当前这一秒，查询过去多少秒内，arr[x] >= v
// 2 <= n、m <= 10^5
// -10^9 <= 数组中的值 <= +10^9
// 测试链接 : https://www.luogu.com.cn/problem/P3863
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Event {
//    int op, x, t, v, q;
//};
//
//bool EventCmp(Event &a, Event &b) {
//    return a.x != b.x ? a.x < b.x : a.t < b.t;
//}
//
//const int MAXN = 100001;
//const int MAXB = 501;
//int n, m;
//int arr[MAXN];
//
//Event event[MAXN << 2];
//int cnte, cntq;
//
//long long tim[MAXN];
//long long sortv[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//long long lazy[MAXB];
//
//int ans[MAXN];
//
//void innerAdd(int l, int r, long long v) {
//    for (int i = l; i <= r; i++) {
//        tim[i] += v;
//    }
//    for (int i = bl[bi[l]]; i <= br[bi[l]]; i++) {
//        sortv[i] = tim[i];
//    }
//    sort(sortv + bl[bi[l]], sortv + br[bi[l]] + 1);
//}
//
//void add(int l, int r, long long v) {
//    if (l > r) {
//        return;
//    }
//    if (bi[l] == bi[r]) {
//        innerAdd(l, r, v);
//    } else {
//        innerAdd(l, br[bi[l]], v);
//        innerAdd(bl[bi[r]], r, v);
//        for (int i = bi[l] + 1; i <= bi[r] - 1; i++) {
//            lazy[i] += v;
//        }
//    }
//}
//
//int innerQuery(int l, int r, long long v) {
//    v -= lazy[bi[l]];
//    int ans = 0;
//    for (int i = l; i <= r; i++) {
//        if (tim[i] >= v) {
//            ans++;
//        }
//    }
//    return ans;
//}
//
//int getCnt(int i, long long v) {
//    v -= lazy[i];
//    int l = bl[i], r = br[i], m, pos = br[i] + 1;
//    while (l <= r) {
//        m = (l + r) >> 1;
//        if (sortv[m] >= v) {
//            pos = m;
//            r = m - 1;
//        } else {
//            l = m + 1;
//        }
//    }
//    return br[i] - pos + 1;
//}
//
//int query(int l, int r, long long v) {
//    if (l > r) {
//        return 0;
//    }
//    int ans = 0;
//    if (bi[l] == bi[r]) {
//    	ans = innerQuery(l, r, v);
//    } else {
//    	ans += innerQuery(l, br[bi[l]], v);
//    	ans += innerQuery(bl[bi[r]], r, v);
//        for (int i = bi[l] + 1; i <= bi[r] - 1; i++) {
//            ans += getCnt(i, v);
//        }
//    }
//    return ans;
//}
//
//void addChange(int x, int t, int v) {
//    event[++cnte].op = 1;
//    event[cnte].x = x;
//    event[cnte].t = t;
//    event[cnte].v = v;
//}
//
//void addQuery(int x, int t, int v) {
//    event[++cnte].op = 2;
//    event[cnte].x = x;
//    event[cnte].t = t;
//    event[cnte].v = v;
//    event[cnte].q = ++cntq;
//}
//
//void prepare() {
//    blen = (int)sqrt(m);
//    bnum = (m + blen - 1) / blen;
//    for (int i = 1; i <= m; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, m);
//    }
//    sort(event + 1, event + cnte + 1, EventCmp);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    m++;
//    for (int t = 2, op, l, r, v, x; t <= m; t++) {
//        cin >> op;
//        if (op == 1) {
//            cin >> l >> r >> v;
//            addChange(l, t, v);
//            addChange(r + 1, t, -v);
//        } else {
//            cin >> x >> v;
//            addQuery(x, t, v);
//        }
//    }
//    prepare();
//    for (int i = 1; i <= cnte; i++) {
//        if (event[i].op == 1) {
//            add(event[i].t, m, event[i].v);
//        } else {
//            ans[event[i].q] = query(1, event[i].t - 1, 1LL * event[i].v - arr[event[i].x]);
//        }
//    }
//    for (int i = 1; i <= cntq; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class174;

// 未来日记，C++版
// 给定一个长度为n的数组arr，一共有m条操作，每条操作类型如下
// 操作 1 l r x y : arr[l..r]范围上，所有值x变成值y
// 操作 2 l r k   : arr[l..r]范围上，查询第k小的值
// 1 <= n、m、arr[i] <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P4119
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//char buf[1000000], *p1 = buf, *p2 = buf;
//
//inline char getChar() {
//    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;
//}
//
//inline int read() {
//    int s = 0;
//    char c = getChar();
//    while (!isdigit(c)) {
//        c = getChar();
//    }
//    while (isdigit(c)) {
//        s = s * 10 + c - '0';
//        c = getChar();
//    }
//    return s;
//}
//
//const int MAXN = 100001;
//const int MAXB = 401;
//int n, m;
//int arr[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//
//int idxset[MAXN];
//int valset[MAXB][MAXN];
//int setval[MAXB][MAXN];
//
//int sum1[MAXB][MAXB];
//int sum2[MAXB][MAXN];
//int cnt1[MAXB];
//int cnt2[MAXN];
//
//void build(int b) {
//    for (int i = 1; i <= blen; i++) {
//        valset[b][setval[b][i]] = 0;
//    }
//    for (int i = bl[b], s = 0; i <= br[b]; i++) {
//        if (valset[b][arr[i]] == 0) {
//            s++;
//            valset[b][arr[i]] = s;
//            setval[b][s] = arr[i];
//        }
//        idxset[i] = valset[b][arr[i]];
//    }
//}
//
//void lazy(int b, int x, int y) {
//    valset[b][y] = valset[b][x];
//    setval[b][valset[b][x]] = y;
//    valset[b][x] = 0;
//}
//
//void down(int b) {
//    for (int i = bl[b]; i <= br[b]; i++) {
//        arr[i] = setval[b][idxset[i]];
//    }
//}
//
//void innerUpdate(int l, int r, int x, int y) {
//    down(bi[l]);
//    for (int i = l; i <= r; i++) {
//        if (arr[i] == x) {
//            sum1[bi[i]][bi[x]]--;
//            sum1[bi[i]][bi[y]]++;
//            sum2[bi[i]][x]--;
//            sum2[bi[i]][y]++;
//            arr[i] = y;
//        }
//    }
//    build(bi[l]);
//}
//
//void update(int l, int r, int x, int y) {
//    if (x == y || (sum2[bi[r]][x] - sum2[bi[l] - 1][x] == 0)) {
//        return;
//    }
//    for (int b = bi[n]; b >= bi[l]; b--) {
//        sum1[b][bi[x]] -= sum1[b - 1][bi[x]];
//        sum1[b][bi[y]] -= sum1[b - 1][bi[y]];
//        sum2[b][x] -= sum2[b - 1][x];
//        sum2[b][y] -= sum2[b - 1][y];
//    }
//    if (bi[l] == bi[r]) {
//        innerUpdate(l, r, x, y);
//    } else {
//        innerUpdate(l, br[bi[l]], x, y);
//        innerUpdate(bl[bi[r]], r, x, y);
//        for (int b = bi[l] + 1; b <= bi[r] - 1; b++) {
//            if (sum2[b][x] != 0) {
//                if (sum2[b][y] != 0) {
//                    innerUpdate(bl[b], br[b], x, y);
//                } else {
//                    sum1[b][bi[y]] += sum2[b][x];
//                    sum1[b][bi[x]] -= sum2[b][x];
//                    sum2[b][y] += sum2[b][x];
//                    sum2[b][x] = 0;
//                    lazy(b, x, y);
//                }
//            }
//        }
//    }
//    for (int b = bi[l]; b <= bi[n]; b++) {
//        sum1[b][bi[x]] += sum1[b - 1][bi[x]];
//        sum1[b][bi[y]] += sum1[b - 1][bi[y]];
//        sum2[b][x] += sum2[b - 1][x];
//        sum2[b][y] += sum2[b - 1][y];
//    }
//}
//
//void addCnt(int l, int r) {
//    for (int i = l; i <= r; i++) {
//        cnt1[bi[arr[i]]]++;
//        cnt2[arr[i]]++;
//    }
//}
//
//void clearCnt(int l, int r) {
//    for (int i = l; i <= r; i++) {
//        cnt1[bi[arr[i]]] = cnt2[arr[i]] = 0;
//    }
//}
//
//int query(int l, int r, int k) {
//    int ans = 0;
//    bool inner = bi[l] == bi[r];
//    if (inner) {
//        down(bi[l]);
//        addCnt(l, r);
//    } else {
//        down(bi[l]);
//        down(bi[r]);
//        addCnt(l, br[bi[l]]);
//        addCnt(bl[bi[r]], r);
//    }
//    int sumCnt = 0;
//    int vblock = 0;
//    for (int b = 1; b <= bi[MAXN - 1]; b++) {
//        int cnt = cnt1[b] + (inner ? 0 : sum1[bi[r] - 1][b] - sum1[bi[l]][b]);
//        if (sumCnt + cnt >= k) {
//            vblock = b;
//            break;
//        } else {
//            sumCnt += cnt;
//        }
//    }
//    for (int v = (vblock - 1) * blen + 1; v <= vblock * blen; v++) {
//        int cnt = cnt2[v] + (inner ? 0 : sum2[bi[r] - 1][v] - sum2[bi[l]][v]);
//        if (sumCnt + cnt >= k) {
//            ans = v;
//            break;
//        } else {
//            sumCnt += cnt;
//        }
//    }
//    if (inner) {
//        clearCnt(l, r);
//    } else {
//        clearCnt(l, br[bi[l]]);
//        clearCnt(bl[bi[r]], r);
//    }
//    return ans;
//}
//
//void prepare() {
//    blen = 300;
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i < MAXN; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, n);
//        build(i);
//    }
//    for (int i = 1; i <= bnum; i++) {
//        for (int j = 1; j < MAXB; j++) {
//            sum1[i][j] = sum1[i - 1][j];
//        }
//        for (int j = 1; j < MAXN; j++) {
//            sum2[i][j] = sum2[i - 1][j];
//        }
//        for (int j = bl[i]; j <= br[i]; j++) {
//            sum1[i][bi[arr[j]]]++;
//            sum2[i][arr[j]]++;
//        }
//    }
//}
//
//int main() {
//    n = read();
//    m = read();
//    for (int i = 1; i <= n; i++) {
//        arr[i] = read();
//    }
//    prepare();
//    for (int i = 1, op, l, r, x, y, k; i <= m; i++) {
//        op = read();
//        l = read();
//        r = read();
//        if (op == 1) {
//            x = read();
//            y = read();
//            update(l, r, x, y);
//        } else {
//            k = read();
//            printf("%d\n", query(l, r, k));
//        }
//    }
//    return 0;
//}

package class174;

// 魔法少女网站，C++版
// 给定一个长度为n的数组arr，一共有m条操作，每条操作类型如下
// 操作 1 x v   : arr[x]的值变成v
// 操作 2 x y v : arr[x..y]范围上，查询有多少连续子数组的最大值 <= v
// 1 <= n、m <= 3 * 10^5
// 1 <= arr[i] <= n
// 测试链接 : https://www.luogu.com.cn/problem/P6578
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//namespace fastio {
//    static const int SZ = 1 << 20;
//    char ibuf[SZ], *is = ibuf, *ie = ibuf;
//    inline int gc() {
//        if (is == ie) {
//            size_t len = fread(ibuf, 1, SZ, stdin);
//            if (len == 0) return -1;
//            is = ibuf;
//            ie = ibuf + len;
//        }
//        return *is++;
//    }
//    template <typename T>
//    inline bool readInt(T& x) {
//        int c = gc(); if (c == -1) return false;
//        bool neg = false;
//        while (c != '-' && (c < '0' || c > '9')) { c = gc(); if (c == -1) return false; }
//        if (c == '-') { neg = true; c = gc(); }
//        x = 0;
//        while (c >= '0' && c <= '9') { x = x * 10 + (c & 15); c = gc(); }
//        if (neg) x = -x;
//        return true;
//    }
//    char obuf[SZ]; char* op = obuf;
//    inline void flush() {
//        fwrite(obuf, 1, op - obuf, stdout);
//        op = obuf;
//    }
//    template <typename T>
//    inline void writeInt(T x, char end = '\n') {
//        if (op > obuf + SZ - 256) flush();
//        if (x == 0) { *op++ = '0'; *op++ = end; return; }
//        if (x < 0) { *op++ = '-'; x = -x; }
//        char s[24]; int n = 0;
//        while (x) { s[n++] = char('0' + x % 10); x /= 10; }
//        while (n) *op++ = s[--n];
//        *op++ = end;
//    }
//}
//
//using fastio::readInt;
//using fastio::writeInt;
//using fastio::flush;
//
//const int MAXN = 300002;
//const int MAXB = 601;
//const int POW = 9;
//const int OFFSET = (1 << POW) - 1;
//int n, m;
//
//int arr[MAXN];
//int op[MAXN];
//int x[MAXN];
//int y[MAXN];
//int v[MAXN];
//
//int pos[MAXN];
//int qid[MAXN];
//int cntp;
//int cntq;
//
//int cntv[MAXB];
//int help[MAXN];
//
//int lst[MAXN];
//int nxt[MAXN];
//
//int pre[MAXN];
//int suf[MAXN];
//int len[MAXN];
//long long ans[MAXN];
//
//inline void radix(int* idx, int* val, int siz) {
//    memset(cntv, 0, sizeof(int) * MAXB);
//    for (int i = 1; i <= siz; i++) cntv[val[idx[i]] & OFFSET]++;
//    for (int i = 1; i < MAXB; i++) cntv[i] += cntv[i - 1];
//    for (int i = siz; i >= 1; i--) help[cntv[val[idx[i]] & OFFSET]--] = idx[i];
//    memcpy(idx + 1, help + 1, siz * sizeof(int));
//    memset(cntv, 0, sizeof(int) * MAXB);
//    for (int i = 1; i <= siz; i++) cntv[val[idx[i]] >> POW]++;
//    for (int i = 1; i < MAXB; i++) cntv[i] += cntv[i - 1];
//    for (int i = siz; i >= 1; i--) help[cntv[val[idx[i]] >> POW]--] = idx[i];
//    memcpy(idx + 1, help + 1, siz * sizeof(int));
//}
//
//inline void merge(int i, int curPre, int curSuf, int curLen, int curAns) {
//    ans[i] += 1L * suf[i] * curPre + curAns;
//    pre[i] = pre[i] + (pre[i] == len[i] ? curPre : 0);
//    suf[i] = curSuf + (curSuf == curLen ? suf[i] : 0);
//    len[i] += curLen;
//}
//
//void calc(int l, int r) {
//    for (int i = l; i <= r; i++) {
//        pos[++cntp] = i;
//        lst[i] = i - 1;
//        nxt[i] = i + 1;
//    }
//    radix(pos, arr, cntp);
//    radix(qid, v, cntq);
//    int curPre = 0, curSuf = 0, curLen = r - l + 1, curAns = 0;
//    for (int i = 1, j = 1, idx; i <= cntq; i++) {
//        while (j <= cntp && arr[pos[j]] <= v[qid[i]]) {
//            idx = pos[j];
//            if (lst[idx] == l - 1) {
//                curPre += nxt[idx] - idx;
//            }
//            if (nxt[idx] == r + 1) {
//                curSuf += idx - lst[idx];
//            }
//            curAns += 1L * (idx - lst[idx]) * (nxt[idx] - idx);
//            lst[nxt[idx]] = lst[idx];
//            nxt[lst[idx]] = nxt[idx];
//            j++;
//        }
//        merge(qid[i], curPre, curSuf, curLen, curAns);
//    }
//    cntp = cntq = 0;
//}
//
//void compute(int l, int r) {
//    for (int qi = 1; qi <= m; qi++) {
//        if (op[qi] == 1) {
//            if (l <= x[qi] && x[qi] <= r) {
//                calc(l, r);
//                arr[x[qi]] = v[qi];
//            }
//        } else {
//            if (x[qi] <= l && r <= y[qi]) {
//                qid[++cntq] = qi;
//            } else {
//                for (int i = max(x[qi], l); i <= min(y[qi], r); i++) {
//                    if (arr[i] <= v[qi]) {
//                        merge(qi, 1, 1, 1, 1);
//                    } else {
//                        merge(qi, 0, 0, 1, 0);
//                    }
//                }
//            }
//        }
//    }
//    calc(l, r);
//}
//
//int main() {
//    readInt(n);
//    readInt(m);
//    for (int i = 1; i <= n; i++) {
//        readInt(arr[i]);
//    }
//    for (int i = 1; i <= m; i++) {
//        readInt(op[i]);
//        readInt(x[i]);
//        if (op[i] == 1) {
//            readInt(v[i]);
//        } else {
//            readInt(y[i]);
//            readInt(v[i]);
//        }
//    }
//    int blen = 1 << POW;
//    int bnum = (n + blen - 1) / blen;
//    for (int i = 1, l, r; i <= bnum; i++) {
//        l = (i - 1) * blen + 1;
//        r = min(i * blen, n);
//        compute(l, r);
//    }
//    for (int i = 1; i <= m; i++) {
//        if (op[i] == 2) {
//            writeInt(ans[i]);
//        }
//    }
//    flush();
//    return 0;
//}

package class175;

// 哈希冲突，C++版
// 给定一个长度为n的数组arr，接下来有m条操作，操作格式如下
// 操作 A x y : 下标 % x == y，符合要求的下标，把对应的值累加起来，打印结果
// 操作 C x y : arr[x]的值改成y
// 1 <= n、m <= 1.5 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P3396
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 150001;
//const int MAXB = 401;
//int n, m, blen;
//int arr[MAXN];
//long long dp[MAXB][MAXB];
//
//long long query(int x, int y) {
//    if (x <= blen) {
//        return dp[x][y];
//    }
//    long long ans = 0;
//    for (int i = y; i <= n; i += x) {
//        ans += arr[i];
//    }
//    return ans;
//}
//
//void update(int i, int v) {
//    int delta = v - arr[i];
//    arr[i] = v;
//    for (int x = 1; x <= blen; x++) {
//        dp[x][i % x] += delta;
//    }
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    for (int x = 1; x <= blen; x++) {
//        for (int i = 1; i <= n; i++) {
//            dp[x][i % x] += arr[i];
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    char op;
//    int x, y;
//    for (int i = 1; i <= m; i++) {
//        cin >> op >> x >> y;
//        if (op == 'A') {
//            cout << query(x, y) << '\n';
//        } else {
//            update(x, y);
//        }
//    }
//    return 0;
//}

package class175;

// 等差数列求和，C++版
// 一共有t组测试，每组测试遵循同样的设定
// 给定一个长度为n的数组arr，接下来有q条查询，查询格式如下
// 查询 s d k : arr[s]作为第1项、arr[s + 1d]作为第2项、arr[s + 2d]作为第3项...
//             每项的值 * 项的编号，一共k项都累加起来，打印累加和
// 1 <= n <= 10^5
// 1 <= q <= 2 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/CF1921F
// 测试链接 : https://codeforces.com/problemset/problem/1921/F
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//const int MAXB = 401;
//int t, n, q, blen;
//int arr[MAXN];
//long long f[MAXB][MAXN];
//long long g[MAXB][MAXN];
//
//long long query(int s, int d, int k) {
//    long long ans = 0;
//    if (d <= blen) {
//        ans = g[d][s];
//        if (s + d * k <= n) {
//            ans -= g[d][s + d * k] + f[d][s + d * k] * k;
//        }
//    } else {
//        for (int i = 1; i <= k; i++) {
//            ans += 1LL * arr[s + (i - 1) * d] * i;
//        }
//    }
//    return ans;
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    for (int d = 1; d <= blen; d++) {
//        for (int i = n; i >= 1; i--) {
//            f[d][i] = arr[i] + (i + d > n ? 0 : f[d][i + d]);
//        }
//    }
//    for (int d = 1; d <= blen; d++) {
//        for (int i = n; i >= 1; i--) {
//            g[d][i] = f[d][i] + (i + d > n ? 0 : g[d][i + d]);
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> t;
//    for (int c = 1; c <= t; c++) {
//        cin >> n >> q;
//        for (int i = 1; i <= n; i++) {
//            cin >> arr[i];
//        }
//        prepare();
//        for (int i = 1, s, d, k; i <= q; i++) {
//            cin >> s >> d >> k;
//            cout << query(s, d, k) << '\n';
//        }
//    }
//    return 0;
//}

package class176;

// 统计出现1次的数，C++版
// 给定一个长度为n的数组arr，下标0~n-1，一共有m条操作，格式如下
// 操作 1 pos val : 把arr[pos]的值设置成val
// 操作 2 l r     : 查询arr[l..r]范围上，有多少种数出现了1次
// 0 <= n、m、arr[i] <= 2 * 10^5 
// 测试链接 : https://www.luogu.com.cn/problem/SP30906
// 测试链接 : https://www.spoj.com/problems/ADAUNIQ/
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, t, id;
//};
//
//struct Update {
//    int pos, val;
//};
//
//const int MAXN = 200001;
//int n, m;
//int arr[MAXN];
//int bi[MAXN];
//
//Query query[MAXN];
//Update update[MAXN];
//int cntq, cntu;
//
//int cnt[MAXN];
//int curCnt;
//
//int ans[MAXN];
//
//bool QueryCmp(Query &a, Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    if (bi[a.r] != bi[b.r]) {
//        return bi[a.r] < bi[b.r];
//    }
//    return a.t < b.t;
//}
//
//void del(int num) {
//    if (cnt[num] == 1) {
//        curCnt--;
//    }
//    if (cnt[num] == 2) {
//        curCnt++;
//    }
//    cnt[num]--;
//}
//
//void add(int num) {
//    if (cnt[num] == 0) {
//        curCnt++;
//    }
//    if (cnt[num] == 1) {
//        curCnt--;
//    }
//    cnt[num]++;
//}
//
//void moveTime(int jobl, int jobr, int tim) {
//    int pos = update[tim].pos;
//    int val = update[tim].val;
//    if (jobl <= pos && pos <= jobr) {
//        del(arr[pos]);
//        add(val);
//    }
//    int tmp = arr[pos];
//    arr[pos] = val;
//    update[tim].val = tmp;
//}
//
//void compute() {
//    int winl = 1, winr = 0, wint = 0;
//    for (int i = 1; i <= cntq; i++) {
//        int jobl = query[i].l;
//        int jobr = query[i].r;
//        int jobt = query[i].t;
//        int id = query[i].id;
//        while (winl > jobl) {
//            add(arr[--winl]);
//        }
//        while (winr < jobr) {
//            add(arr[++winr]);
//        }
//        while (winl < jobl) {
//            del(arr[winl++]);
//        }
//        while (winr > jobr) {
//            del(arr[winr--]);
//        }
//        while (wint < jobt) {
//            moveTime(jobl, jobr, ++wint);
//        }
//        while (wint > jobt) {
//            moveTime(jobl, jobr, wint--);
//        }
//        ans[id] = curCnt;
//     }
//}
//
//void prepare() {
//    int blen = max(1, (int)pow(n, 2.0 / 3));
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    sort(query + 1, query + cntq + 1, QueryCmp);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1, op, l, r, pos, val; i <= m; i++) {
//        cin >> op;
//        if (op == 1) {
//            cin >> pos >> val;
//            cntu++;
//            update[cntu].pos = pos + 1;
//            update[cntu].val = val;
//        } else {
//            cin >> l >> r;
//            cntq++;
//            query[cntq].l = l + 1;
//            query[cntq].r = r + 1;
//            query[cntq].t = cntu;
//            query[cntq].id = cntq;
//        }
//    }
//    prepare();
//    compute();
//    for (int i = 1; i <= cntq; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class177;

// 只增回滚莫队入门题，C++版
// 给定一个长度为n的数组arr，下面定义重要度的概念
// 如果一段范围上，数字x出现c次，那么这个数字的重要度为x * c
// 范围上的最大重要度，就是该范围上，每种数字的重要度，取最大值
// 一共有m条查询，格式 l r : 打印arr[l..r]范围上的最大重要度
// 1 <= n、m <= 10^5
// 1 <= arr[i] <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/AT_joisc2014_c
// 测试链接 : https://atcoder.jp/contests/joisc2014/tasks/joisc2014_c
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, id;
//};
//
//const int MAXN = 100001;
//const int MAXB = 401;
//int n, m;
//int arr[MAXN];
//Query query[MAXN];
//int sorted[MAXN];
//int cntv;
//
//int blen, bnum;
//int bi[MAXN];
//int br[MAXB];
//
//int cnt[MAXN];
//long long curAns = 0;
//
//long long ans[MAXN];
//
//bool QueryCmp(Query &a, Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    return a.r < b.r;
//}
//
//int kth(int num) {
//    int left = 1, right = cntv, ret = 0;
//    while (left <= right) {
//        int mid = (left + right) >> 1;
//        if (sorted[mid] <= num) {
//            ret = mid;
//            left = mid + 1;
//        } else {
//            right = mid - 1;
//        }
//    }
//    return ret;
//}
//
//long long force(int l, int r) {
//    long long ret = 0;
//    for (int i = l; i <= r; i++) {
//        cnt[arr[i]]++;
//    }
//    for (int i = l; i <= r; i++) {
//        ret = max(ret, 1LL * cnt[arr[i]] * sorted[arr[i]]);
//    }
//    for (int i = l; i <= r; i++) {
//        cnt[arr[i]]--;
//    }
//    return ret;
//}
//
//void add(int num) {
//    cnt[num]++;
//    curAns = max(curAns, 1LL * cnt[num] * sorted[num]);
//}
//
//void del(int num) {
//    cnt[num]--;
//}
//
//void compute() {
//    for (int block = 1, qi = 1; block <= bnum && qi <= m; block++) {
//        curAns = 0;
//        fill(cnt + 1, cnt + cntv + 1, 0);
//        int winl = br[block] + 1, winr = br[block];
//        for (; qi <= m && bi[query[qi].l] == block; qi++) {
//            int jobl = query[qi].l;
//            int jobr = query[qi].r;
//            int id = query[qi].id;
//            if (jobr <= br[block]) {
//                ans[id] = force(jobl, jobr);
//            } else {
//                while (winr < jobr) {
//                    add(arr[++winr]);
//                }
//                long long backup = curAns;
//                while (winl > jobl) {
//                    add(arr[--winl]);
//                }
//                ans[id] = curAns;
//                curAns = backup;
//                while (winl <= br[block]) {
//                    del(arr[winl++]);
//                }
//            }
//        }
//    }
//}
//
//void prepare() {
//    for (int i = 1; i <= n; i++) {
//    	sorted[i] = arr[i];
//    }
//    sort(sorted + 1, sorted + n + 1);
//    cntv = 1;
//    for (int i = 2; i <= n; i++) {
//        if (sorted[cntv] != sorted[i]) {
//        	sorted[++cntv] = sorted[i];
//        }
//    }
//    for (int i = 1; i <= n; i++) {
//        arr[i] = kth(arr[i]);
//    }
//    blen = (int)sqrt(n);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        br[i] = min(i * blen, n);
//    }
//    sort(query + 1, query + m + 1, QueryCmp);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1; i <= m; i++) {
//        cin >> query[i].l >> query[i].r;
//        query[i].id = i;
//    }
//    prepare();
//    compute();
//    for (int i = 1; i <= m; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class177;

// 只删回滚莫队入门题，C++版
// 本题最优解为主席树，讲解158，题目2，已经讲述
// 给定一个长度为n的数组arr，一共有m条查询，格式如下
// 查询 l r : 打印arr[l..r]内没有出现过的最小自然数，注意0是自然数
// 0 <= n、m、arr[i] <= 2 * 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P4137
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, id;
//};
//
//const int MAXN = 200001;
//const int MAXB = 501;
//int n, m;
//int arr[MAXN];
//Query query[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//
//int cnt[MAXN];
//int mex;
//int ans[MAXN];
//
//bool QueryCmp(Query &a, Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    return b.r < a.r;
//}
//
//void del(int num) {
//    if (--cnt[num] == 0) {
//        mex = min(mex, num);
//    }
//}
//
//void add(int num) {
//    cnt[num]++;
//}
//
//void compute() {
//    for (int i = 1; i <= n; i++) {
//        cnt[arr[i]]++;
//    }
//    mex = 0;
//    while (cnt[mex] != 0) {
//        mex++;
//    }
//    int winl = 1, winr = n;
//    for (int block = 1, qi = 1; block <= bnum && qi <= m; block++) {
//        while (winl < bl[block]) {
//            del(arr[winl++]);
//        }
//        int beforeJob = mex;
//        for (; qi <= m && bi[query[qi].l] == block; qi++) {
//            int jobl = query[qi].l;
//            int jobr = query[qi].r;
//            int id = query[qi].id;
//            while (winr > jobr) {
//                del(arr[winr--]);
//            }
//            int backup = mex;
//            while (winl < jobl) {
//                del(arr[winl++]);
//            }
//            ans[id] = mex;
//            mex = backup;
//            while (winl > bl[block]) {
//                add(arr[--winl]);
//            }
//        }
//        while (winr < n) {
//            add(arr[++winr]);
//        }
//        mex = beforeJob;
//    }
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//    }
//    sort(query + 1, query + m + 1, QueryCmp);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1; i <= m; i++) {
//        cin >> query[i].l >> query[i].r;
//        query[i].id = i;
//    }
//    prepare();
//    compute();
//    for (int i = 1; i <= m; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class177;

// 树上莫队入门题，C++版
// 一共有n个节点，每个节点给定颜色值，给定n-1条边，所有节点连成一棵树
// 一共有m条查询，格式 u v : 打印点u到点v的简单路径上，有几种不同的颜色
// 1 <= n <= 4 * 10^4
// 1 <= m <= 10^5
// 1 <= 颜色值 <= 2 * 10^9
// 测试链接 : https://www.luogu.com.cn/problem/SP10707
// 测试链接 : https://www.spoj.com/problems/COT2/
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, lca, id;
//};
//
//const int MAXN = 40001;
//const int MAXM = 100001;
//const int MAXP = 20;
//
//int n, m;
//int color[MAXN];
//int sorted[MAXN];
//int cntv;
//
//Query query[MAXM];
//
//int head[MAXN];
//int to[MAXN << 1];
//int nxt[MAXN << 1];
//int cntg;
//
//int dep[MAXN];
//int seg[MAXN << 1];
//int st[MAXN];
//int ed[MAXN];
//int stjump[MAXN][MAXP];
//int cntd;
//
//int bi[MAXN << 1];
//
//bool vis[MAXN];
//int cnt[MAXN];
//int kind;
//
//int ans[MAXM];
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//}
//
//int kth(int num) {
//    int left = 1, right = cntv, mid, ret = 0;
//    while (left <= right) {
//        mid = (left + right) >> 1;
//        if (sorted[mid] <= num) {
//            ret = mid;
//            left = mid + 1;
//        } else {
//            right = mid - 1;
//        }
//    }
//    return ret;
//}
//
//void dfs(int u, int fa) {
//    dep[u] = dep[fa] + 1;
//    seg[++cntd] = u;
//    st[u] = cntd;
//    stjump[u][0] = fa;
//    for (int p = 1; p < MAXP; p++) {
//        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
//    }
//    for (int e = head[u], v; e > 0; e = nxt[e]) {
//        v = to[e];
//        if (v != fa) {
//            dfs(v, u);
//        }
//    }
//    seg[++cntd] = u;
//    ed[u] = cntd;
//}
//
//int lca(int a, int b) {
//    if (dep[a] < dep[b]) {
//        swap(a, b);
//    }
//    for (int p = MAXP - 1; p >= 0; p--) {
//        if (dep[stjump[a][p]] >= dep[b]) {
//            a = stjump[a][p];
//        }
//    }
//    if (a == b) {
//        return a;
//    }
//    for (int p = MAXP - 1; p >= 0; p--) {
//        if (stjump[a][p] != stjump[b][p]) {
//            a = stjump[a][p];
//            b = stjump[b][p];
//        }
//    }
//    return stjump[a][0];
//}
//
//bool QueryCmp(Query &a, Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    return a.r < b.r;
//}
//
//void invert(int node) {
//    int val = color[node];
//    if (vis[node]) {
//        if (--cnt[val] == 0) {
//            kind--;
//        }
//    } else {
//        if (++cnt[val] == 1) {
//            kind++;
//        }
//    }
//    vis[node] = !vis[node];
//}
//
//void compute() {
//    int winl = 1, winr = 0;
//    for (int i = 1; i <= m; i++) {
//        int jobl = query[i].l;
//        int jobr = query[i].r;
//        int lca = query[i].lca;
//        int id = query[i].id;
//        while (winl > jobl) {
//            invert(seg[--winl]);
//        }
//        while (winr < jobr) {
//            invert(seg[++winr]);
//        }
//        while (winl < jobl) {
//            invert(seg[winl++]);
//        }
//        while (winr > jobr) {
//            invert(seg[winr--]);
//        }
//        if (lca > 0) {
//            invert(lca);
//        }
//        ans[id] = kind;
//        if (lca > 0) {
//            invert(lca);
//        }
//    }
//}
//
//void prepare() {
//    for (int i = 1; i <= n; i++) {
//        sorted[i] = color[i];
//    }
//    sort(sorted + 1, sorted + n + 1);
//    cntv = 1;
//    for (int i = 2; i <= n; i++) {
//        if (sorted[cntv] != sorted[i]) {
//            sorted[++cntv] = sorted[i];
//        }
//    }
//    for (int i = 1; i <= n; i++) {
//        color[i] = kth(color[i]);
//    }
//    int blen = (int) sqrt(cntd);
//    for (int i = 1; i <= cntd; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    sort(query + 1, query + m + 1, QueryCmp);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> color[i];
//    }
//    for (int i = 1, u, v; i < n; i++) {
//        cin >> u >> v;
//        addEdge(u, v);
//        addEdge(v, u);
//    }
//    dfs(1, 0);
//    for (int i = 1, u, v, uvlca; i <= m; i++) {
//        cin >> u >> v;
//        if (st[v] < st[u]) {
//            swap(u, v);
//        }
//        uvlca = lca(u, v);
//        if (u == uvlca) {
//            query[i].l = st[u];
//            query[i].r = st[v];
//            query[i].lca = 0;
//        } else {
//            query[i].l = ed[u];
//            query[i].r = st[v];
//            query[i].lca = uvlca;
//        }
//        query[i].id = i;
//    }
//    prepare();
//    compute();
//    for (int i = 1; i <= m; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class178;

// 莫队二次离线入门题，C++版
// 给定一个长度为n的数组arr，给定一个非负整数k，下面给出k1二元组的定义
// 位置二元组(i, j)，i和j必须是不同的，并且 arr[i]异或arr[j] 的二进制状态里有k个1
// 当i != j时，(i, j)和(j, i)认为是相同的二元组
// 一共有m条查询，格式为 l r : 打印arr[l..r]范围上，有多少k1二元组
// 1 <= n、m <= 10^5
// 0 <= arr[i]、k < 16384(2的14次方)
// 测试链接 : https://www.luogu.com.cn/problem/P4887
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, id;
//};
//
//const int MAXN = 100002;
//const int MAXV = 1 << 14;
//int n, m, k;
//int arr[MAXN];
//int bi[MAXN];
//int kOneArr[MAXV];
//int cntk;
//
//Query query[MAXN];
//
//int headl[MAXN];
//int headr[MAXN];
//int nextq[MAXN << 1];
//int ql[MAXN << 1];
//int qr[MAXN << 1];
//int qop[MAXN << 1];
//int qid[MAXN << 1];
//int cntq;
//
//int cnt[MAXV];
//long long pre[MAXN];
//long long suf[MAXN];
//
//long long ans[MAXN];
//
//bool QueryCmp(Query &a, Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    return a.r < b.r;
//}
//
//int lowbit(int x) {
//    return x & -x;
//}
//
//int countOne(int num) {
//    int ret = 0;
//    while (num > 0) {
//        ret++;
//        num -= lowbit(num);
//    }
//    return ret;
//}
//
//void addLeftOffline(int x, int l, int r, int op, int id) {
//    nextq[++cntq] = headl[x];
//    headl[x] = cntq;
//    ql[cntq] = l;
//    qr[cntq] = r;
//    qop[cntq] = op;
//    qid[cntq] = id;
//}
//
//void addRightOffline(int x, int l, int r, int op, int id) {
//    nextq[++cntq] = headr[x];
//    headr[x] = cntq;
//    ql[cntq] = l;
//    qr[cntq] = r;
//    qop[cntq] = op;
//    qid[cntq] = id;
//}
//
//void prepare() {
//    int blen = (int)sqrt(n);
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    sort(query + 1, query + m + 1, QueryCmp);
//    for (int v = 0; v < MAXV; v++) {
//        if (countOne(v) == k) {
//            kOneArr[++cntk] = v;
//        }
//    }
//}
//
//void compute() {
//    for (int i = 1; i <= n; i++) {
//        pre[i] = pre[i - 1] + cnt[arr[i]];
//        for (int j = 1; j <= cntk; j++) {
//            cnt[arr[i] ^ kOneArr[j]]++;
//        }
//    }
//    memset(cnt, 0, sizeof(cnt));
//    for (int i = n; i >= 1; i--) {
//        suf[i] = suf[i + 1] + cnt[arr[i]];
//        for (int j = 1; j <= cntk; j++) {
//            cnt[arr[i] ^ kOneArr[j]]++;
//        }
//    }
//    int winl = 1, winr = 0;
//    for (int i = 1; i <= m; i++) {
//        int jobl = query[i].l;
//        int jobr = query[i].r;
//        int id = query[i].id;
//        if (winr < jobr) {
//            addLeftOffline(winl - 1, winr + 1, jobr, -1, id);
//            ans[id] += pre[jobr] - pre[winr];
//        }
//        if (winr > jobr) {
//            addLeftOffline(winl - 1, jobr + 1, winr, 1, id);
//            ans[id] -= pre[winr] - pre[jobr];
//        }
//        winr = jobr;
//        if (winl > jobl) {
//            addRightOffline(winr + 1, jobl, winl - 1, -1, id);
//            ans[id] += suf[jobl] - suf[winl];
//        }
//        if (winl < jobl) {
//            addRightOffline(winr + 1, winl, jobl - 1, 1, id);
//            ans[id] -= suf[winl] - suf[jobl];
//        }
//        winl = jobl;
//    }
//    memset(cnt, 0, sizeof(cnt));
//    for (int x = 0; x <= n; x++) {
//        if (x >= 1) {
//            for (int j = 1; j <= cntk; j++) {
//                cnt[arr[x] ^ kOneArr[j]]++;
//            }
//        }
//        for (int q = headl[x]; q > 0; q = nextq[q]) {
//            int l = ql[q], r = qr[q], op = qop[q], id = qid[q];
//            for (int j = l; j <= r; j++) {
//                ans[id] += 1LL * op * cnt[arr[j]];
//            }
//        }
//    }
//    memset(cnt, 0, sizeof(cnt));
//    for (int x = n + 1; x >= 1; x--) {
//        if (x <= n) {
//            for (int j = 1; j <= cntk; j++) {
//                cnt[arr[x] ^ kOneArr[j]]++;
//            }
//        }
//        for (int q = headr[x]; q > 0; q = nextq[q]) {
//            int l = ql[q], r = qr[q], op = qop[q], id = qid[q];
//            for (int j = l; j <= r; j++) {
//                ans[id] += 1LL * op * cnt[arr[j]];
//            }
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m >> k;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1; i <= m; i++) {
//        cin >> query[i].l >> query[i].r;
//        query[i].id = i;
//    }
//    prepare();
//    compute();
//    for (int i = 2; i <= m; i++) {
//        ans[query[i].id] += ans[query[i - 1].id];
//    }
//    for (int i = 1; i <= m; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class178;

// 区间逆序对，C++版
// 给定一个长度为n的数组arr，如果i < j，并且arr[i] > arr[j]，那么(i,j)就是逆序对
// 一共有m条查询，格式为 l r : 打印arr[l..r]范围上，逆序对的数量
// 1 <= n、m <= 10^5
// 0 <= arr[i] <= 10^9
// 本题允许离线，讲解173，题目4，讲了在线查询区间逆序对，但是给定的数组为排列
// 测试链接 : https://www.luogu.com.cn/problem/P5047
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, id;
//};
//
//const int MAXN = 100002;
//const int MAXB = 401;
//
//int n, m;
//int arr[MAXN];
//int sorted[MAXN];
//int cntv;
//
//Query query[MAXN];
//int headl[MAXN];
//int headr[MAXN];
//int nextq[MAXN << 1];
//int ql[MAXN << 1];
//int qr[MAXN << 1];
//int qop[MAXN << 1];
//int qid[MAXN << 1];
//int cntq;
//
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//
//int tree[MAXN];
//long long pre[MAXN];
//long long suf[MAXN];
//
//long long blockCnt[MAXB];
//long long numCnt[MAXN];
//
//long long ans[MAXN];
//
//bool QueryCmp(Query &a, Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    return a.r < b.r;
//}
//
//int kth(int num) {
//    int left = 1, right = cntv, ret = 0;
//    while (left <= right) {
//        int mid = (left + right) >> 1;
//        if (sorted[mid] <= num) {
//            ret = mid;
//            left = mid + 1;
//        } else {
//            right = mid - 1;
//        }
//    }
//    return ret;
//}
//
//int lowbit(int i) {
//    return i & -i;
//}
//
//void add(int i, int v) {
//    while (i <= cntv) {
//        tree[i] += v;
//        i += lowbit(i);
//    }
//}
//
//int sum(int i) {
//    int ret = 0;
//    while (i > 0) {
//        ret += tree[i];
//        i -= lowbit(i);
//    }
//    return ret;
//}
//
//void addLeftOffline(int x, int l, int r, int op, int id) {
//    nextq[++cntq] = headl[x];
//    headl[x] = cntq;
//    ql[cntq] = l;
//    qr[cntq] = r;
//    qop[cntq] = op;
//    qid[cntq] = id;
//}
//
//void addRightOffline(int x, int l, int r, int op, int id) {
//    nextq[++cntq] = headr[x];
//    headr[x] = cntq;
//    ql[cntq] = l;
//    qr[cntq] = r;
//    qop[cntq] = op;
//    qid[cntq] = id;
//}
//
//void addLeftCnt(int val) {
//    for (int b = 1; b <= bi[val] - 1; b++) {
//        blockCnt[b]++;
//    }
//    for (int i = bl[bi[val]]; i < val; i++) {
//        numCnt[i]++;
//    }
//}
//
//void addRightCnt(int val) {
//    for (int b = bi[val] + 1; b <= bi[cntv]; b++) {
//        blockCnt[b]++;
//    }
//    for (int i = val + 1; i <= br[bi[val]]; i++) {
//        numCnt[i]++;
//    }
//}
//
//long long getCnt(int val) {
//    return blockCnt[bi[val]] + numCnt[val];
//}
//
//void prepare() {
//    for (int i = 1; i <= n; i++) {
//        sorted[i] = arr[i];
//    }
//    sort(sorted + 1, sorted + n + 1);
//    cntv = 1;
//    for (int i = 2; i <= n; i++) {
//        if (sorted[cntv] != sorted[i]) {
//            sorted[++cntv] = sorted[i];
//        }
//    }
//    for (int i = 1; i <= n; i++) {
//        arr[i] = kth(arr[i]);
//    }
//    int blen = (int)sqrt(n);
//    int bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, cntv);
//    }
//    sort(query + 1, query + m + 1, QueryCmp);
//}
//
//void compute() {
//    for (int i = 1; i <= n; i++) {
//        pre[i] = pre[i - 1] + sum(cntv) - sum(arr[i]);
//        add(arr[i], 1);
//    }
//    memset(tree + 1, 0, cntv * sizeof(int));
//    for (int i = n; i >= 1; i--) {
//        suf[i] = suf[i + 1] + sum(arr[i] - 1);
//        add(arr[i], 1);
//    }
//    int winl = 1, winr = 0;
//    for (int i = 1; i <= m; i++) {
//        int jobl = query[i].l;
//        int jobr = query[i].r;
//        int id = query[i].id;
//        if (winr < jobr) {
//            addLeftOffline(winl - 1, winr + 1, jobr, -1, id);
//            ans[id] += pre[jobr] - pre[winr];
//        }
//        if (winr > jobr) {
//            addLeftOffline(winl - 1, jobr + 1, winr, 1, id);
//            ans[id] -= pre[winr] - pre[jobr];
//        }
//        winr = jobr;
//        if (winl > jobl) {
//            addRightOffline(winr + 1, jobl, winl - 1, -1, id);
//            ans[id] += suf[jobl] - suf[winl];
//        }
//        if (winl < jobl) {
//            addRightOffline(winr + 1, winl, jobl - 1, 1, id);
//            ans[id] -= suf[winl] - suf[jobl];
//        }
//        winl = jobl;
//    }
//    for (int x = 0; x <= n; x++) {
//        if (x >= 1) {
//            addLeftCnt(arr[x]);
//        }
//        for (int q = headl[x]; q > 0; q = nextq[q]) {
//            int l = ql[q], r = qr[q], op = qop[q], id = qid[q];
//            long long ret = 0;
//            for (int j = l; j <= r; j++) {
//                ret += getCnt(arr[j]);
//            }
//            ans[id] += ret * op;
//        }
//    }
//    memset(blockCnt, 0, sizeof(blockCnt));
//    memset(numCnt, 0, sizeof(numCnt));
//    for (int x = n + 1; x >= 1; x--) {
//        if (x <= n) {
//            addRightCnt(arr[x]);
//        }
//        for (int q = headr[x]; q > 0; q = nextq[q]) {
//            int l = ql[q], r = qr[q], op = qop[q], id = qid[q];
//            long long ret = 0;
//            for (int j = l; j <= r; j++) {
//                ret += getCnt(arr[j]);
//            }
//            ans[id] += ret * op;
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1; i <= m; i++) {
//        cin >> query[i].l >> query[i].r;
//        query[i].id = i;
//    }
//    prepare();
//    compute();
//    for (int i = 2; i <= m; i++) {
//        ans[query[i].id] += ans[query[i - 1].id];
//    }
//    for (int i = 1; i <= m; i++) {
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

package class173;

// 区间逆序对，C++版
// 给定一个长度为n的排列，接下来有m条操作，每条操作格式如下
// 操作 l r : 打印arr[l..r]范围上的逆序对数量
// 1 <= n、m <= 10^5
// 题目要求强制在线，具体规则可以打开测试链接查看
// 测试链接 : https://www.luogu.com.cn/problem/P5046
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例
// 这道题比较卡常，C++实现也需要优化常数，比如快读
// 正式比赛不卡常

//#include <bits/stdc++.h>
//
//using namespace std;
//
//char buf[1000000], *p1 = buf, *p2 = buf;
//
//inline char getChar() {
//    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;
//}
//
//inline int read() {
//    int s = 0;
//    char c = getChar();
//    while (!isdigit(c)) {
//        c = getChar();
//    }
//    while (isdigit(c)) {
//        s = s * 10 + c - '0';
//        c = getChar();
//    }
//    return s;
//}
//
//struct Node {
//    int v, i;
//};
//
//bool NodeCmp(Node &a, Node &b) {
//    return a.v != b.v ? a.v < b.v : a.i < b.i;
//}
//
//const int MAXN = 100001;
//const int MAXB = 701;
//int n, m;
//int arr[MAXN];
//Node sortv[MAXN];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//
//int tree[MAXN];
//
//int pre[MAXN];
//int suf[MAXN];
//int cnt[MAXB][MAXN];
//long long dp[MAXB][MAXB];
//
//inline int lowbit(int i) {
//    return i & -i;
//}
//
//inline void add(int i, int v) {
//    while (i <= n) {
//        tree[i] += v;
//        i += lowbit(i);
//    }
//}
//
//inline int sum(int i) {
//    int ret = 0;
//    while (i > 0) {
//        ret += tree[i];
//        i -= lowbit(i);
//    }
//    return ret;
//}
//
//inline int f(int x, int xl, int xr, int y, int yl, int yr) {
//    int ans = 0;
//    for (int p1 = bl[x], p2 = bl[y] - 1, cnt = 0; p1 <= br[x]; p1++) {
//        if (xl <= sortv[p1].i && sortv[p1].i <= xr) {
//            while (p2 + 1 <= br[y] && sortv[p1].v > sortv[p2 + 1].v) {
//                p2++;
//                if (yl <= sortv[p2].i && sortv[p2].i <= yr) {
//                    cnt++;
//                }
//            }
//            ans += cnt;
//        }
//    }
//    return ans;
//}
//
//long long query(int l, int r) {
//    long long ans = 0;
//    int lb = bi[l], rb = bi[r];
//    if (lb == rb) {
//        if (l == bl[lb]) {
//            ans = pre[r];
//        } else {
//            ans = pre[r] - pre[l - 1] - f(lb, bl[lb], l - 1, lb, l, r);
//        }
//    } else {
//        ans = suf[l] + pre[r] + f(lb, l, br[lb], rb, bl[rb], r);
//        for (int i = l; i <= br[lb]; i++) {
//            ans += cnt[rb - 1][arr[i]] - cnt[lb][arr[i]];
//        }
//        for (int i = bl[rb]; i <= r; i++) {
//            ans += br[rb - 1] - bl[lb + 1] + 1 - (cnt[rb - 1][arr[i]] - cnt[lb][arr[i]]);
//        }
//        ans += dp[lb + 1][rb - 1];
//    }
//    return ans;
//}
//
//void prepare() {
//    blen = (int)sqrt(n / 4);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) bi[i] = (i - 1) / blen + 1;
//    for (int i = 1; i <= bnum; i++) {
//        bl[i] = (i - 1) * blen + 1;
//        br[i] = min(i * blen, n);
//    }
//    for (int i = 1; i <= n; i++) {
//        sortv[i].v = arr[i];
//        sortv[i].i = i;
//    }
//    for (int i = 1; i <= bnum; i++) {
//        sort(sortv + bl[i], sortv + br[i] + 1, NodeCmp);
//    }
//    for (int i = 1; i <= bnum; i++) {
//        for (int j = bl[i]; j <= br[i]; j++) {
//            cnt[i][arr[j]]++;
//            if (j != bl[i]) {
//                pre[j] = pre[j - 1] + sum(n) - sum(arr[j]);
//            }
//            add(arr[j], 1);
//        }
//        for (int j = bl[i]; j <= br[i]; j++) {
//            add(arr[j], -1);
//        }
//        for (int j = br[i]; j >= bl[i]; j--) {
//            if (j != br[i]) {
//                suf[j] = suf[j + 1] + sum(arr[j]);
//            }
//            add(arr[j], 1);
//        }
//        for (int j = bl[i]; j <= br[i]; j++) {
//            add(arr[j], -1);
//        }
//        int tmp = 0;
//        for (int j = 1; j <= n; j++) {
//            tmp += cnt[i][j];
//            cnt[i][j] = tmp + cnt[i - 1][j];
//        }
//    }
//    for (int l = bnum; l >= 1; l--) {
//        dp[l][l] = pre[br[l]];
//        for (int r = l + 1; r <= bnum; r++) {
//            dp[l][r] = dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1] + f(l, bl[l], br[l], r, bl[r], br[r]);
//        }
//    }
//}
//
//int main() {
//    n = read();
//    m = read();
//    for (int i = 1; i <= n; i++) {
//        arr[i] = read();
//    }
//    prepare();
//    long long lastAns = 0;
//    for (int i = 1, l, r; i <= m; i++) {
//        l = read() ^ lastAns;
//        r = read() ^ lastAns;
//        lastAns = query(l, r);
//        printf("%lld\n", lastAns);
//    }
//    return 0;
//}

package class179;

// 由乃的玉米田，C++版
// 给定一个长度为n的数组arr，接下来有m条查询，查询格式如下
// 查询 1 l r x : 打印arr[l..r]范围上能否选出两个数，减的结果为x
// 查询 2 l r x : 打印arr[l..r]范围上能否选出两个数，加的结果为x
// 查询 3 l r x : 打印arr[l..r]范围上能否选出两个数，乘的结果为x
// 查询 4 l r x : 打印arr[l..r]范围上能否选出两个数，除的结果为x，并且没有余数
// 选出的这两个数可以是同一个位置的数，答案如果为是，打印 "yuno"，否则打印 "yumi"
// 1 <= 所有数据 <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P5355
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, x, op, id;
//};
//
//const int MAXN = 100001;
//const int MAXV = 100000;
//const int MAXB = 401;
//int n, m, blen;
//int arr[MAXN];
//int bi[MAXN];
//
//Query query[MAXN];
//int cntq = 0;
//
//int headq[MAXB];
//int nextq[MAXN];
//int ql[MAXN];
//int qr[MAXN];
//int qid[MAXN];
//int cnts = 0;
//
//int cnt[MAXN];
//bitset<MAXN> bitSet1;
//bitset<MAXN> bitSet2;
//
//int pre[MAXN];
//int dp[MAXN];
//
//bool ans[MAXN];
//
//void addSpecial(int x, int l, int r, int id) {
//    nextq[++cnts] = headq[x];
//    headq[x] = cnts;
//    ql[cnts] = l;
//    qr[cnts] = r;
//    qid[cnts] = id;
//}
//
//bool QueryCmp(const Query &a, const Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    if (bi[a.l] & 1) {
//        return a.r < b.r;
//    } else {
//        return a.r > b.r;
//    }
//}
//
//void add(int x) {
//    cnt[x]++;
//    if (cnt[x] == 1) {
//        bitSet1[x] = 1;
//        bitSet2[MAXV - x] = 1;
//    }
//}
//
//void del(int x) {
//    cnt[x]--;
//    if (cnt[x] == 0) {
//        bitSet1[x] = 0;
//        bitSet2[MAXV - x] = 0;
//    }
//}
//
//bool calc(int op, int x) {
//    if (op == 1) {
//        return (bitSet1 & (bitSet1 >> x)).any();
//    } else if (op == 2) {
//        return (bitSet1 & (bitSet2 >> (MAXV - x))).any();
//    } else if (op == 3) {
//        for (int f = 1; f * f <= x; f++) {
//            if (x % f == 0 && bitSet1[f] && bitSet1[x / f]) {
//                    return true;
//            }
//        }
//        return false;
//    } else {
//        for (int i = 1; i * x <= MAXV; i++) {
//            if (bitSet1[i] && bitSet1[i * x]) {
//                return true;
//            }
//        }
//        return false;
//    }
//}
//
//void compute() {
//    int winl = 1, winr = 0;
//    for (int i = 1; i <= cntq; i++) {
//        int jobl = query[i].l;
//        int jobr = query[i].r;
//        int jobx = query[i].x;
//        int op = query[i].op;
//        int id = query[i].id;
//        while (winl > jobl) {
//            add(arr[--winl]);
//        }
//        while (winr < jobr) {
//            add(arr[++winr]);
//        }
//        while (winl < jobl) {
//            del(arr[winl++]);
//        }
//        while (winr > jobr) {
//            del(arr[winr--]);
//        }
//        ans[id] = calc(op, jobx);
//    }
//}
//
//void special() {
//    for (int x = 1; x < blen; x++) {
//        if (headq[x] != 0) {
//            memset(pre, 0, sizeof(int) * (MAXV + 1));
//            memset(dp, 0, sizeof(int) * (n + 1));
//            for (int i = 1; i <= n; i++) {
//                int v = arr[i];
//                pre[v] = i;
//                dp[i] = dp[i-1];
//                if (v * x <= MAXV) {
//                    dp[i] = max(dp[i], pre[v * x]);
//                }
//                if (v % x == 0) {
//                    dp[i] = max(dp[i], pre[v / x]);
//                }
//            }
//            for (int q = headq[x]; q > 0; q = nextq[q]) {
//                int l = ql[q];
//                int r = qr[q];
//                int id = qid[q];
//                ans[id] = (l <= dp[r]);
//            }
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    blen = (int)sqrt(MAXV);
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    for (int i = 1, op, l, r, x; i <= m; i++) {
//        cin >> op >> l >> r >> x;
//        if (op == 4 && x < blen) {
//            addSpecial(x, l, r, i);
//        } else {
//            query[++cntq] = {l, r, x, op, i};
//        }
//    }
//    sort(query + 1, query + cntq + 1, QueryCmp);
//    compute();
//    special();
//    for (int i = 1; i <= m; i++) {
//        cout << (ans[i] ? "yuno" : "yumi") << '\n';
//    }
//    return 0;
//}

package class179;

// 掉进兔子洞，C++版
// 三个区间同时出现的数，一个一个删掉，直到无法再删，剩下数字的个数叫做 剩余个数
// A = [1 2 2 3 3 3]    B = [1 2 2 3 3 3]    C = [1 1 2 3 3]
// 删除的过程为，一起删掉一个1、一起删掉一个2、一起删掉2个3，然后状况为
// A = [2 3]    B = [2 3]    C = [1]    剩余个数为5
// 给定一个长度为n的数组arr，下来有m条查询，格式如下
// 查询 l1 r1 l2 r2 l3 r3 : 给定了三个区间，打印剩余个数
// 1 <= n、m <= 10^5
// 1 <= arr[i] <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/P4688
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Query {
//    int l, r, id;
//};
//
//const int MAXN = 100001;
//const int MAXT = 30001;
//int n, m;
//int arr[MAXN];
//
//int sorted[MAXN];
//int bi[MAXN];
//
//int cnt[MAXN];
//bitset<MAXN> curSet;
//bool hasSet[MAXT];
//bitset<MAXN> bitSet[MAXT];
//
//Query query[MAXT * 3];
//
//int ans[MAXT];
//
//int kth(int num) {
//    int left = 1, right = n, ret = -1;
//    while (left <= right) {
//        int mid = (left + right) >> 1;
//        if (sorted[mid] >= num) {
//            ret = mid;
//            right = mid - 1;
//        } else {
//            left = mid + 1;
//        }
//    }
//    return ret;
//}
//
//bool QueryCmp(const Query &a, const Query &b) {
//    if (bi[a.l] != bi[b.l]) {
//        return bi[a.l] < bi[b.l];
//    }
//    if (bi[a.l] & 1) {
//        return a.r < b.r;
//    } else {
//        return a.r > b.r;
//    }
//}
//
//void add(int x) {
//    cnt[x]++;
//    curSet[x + cnt[x] - 1] = 1;
//}
//
//void del(int x) {
//    cnt[x]--;
//    curSet[x + cnt[x]] = 0;
//}
//
//void compute(int q) {
//    int winl = 1, winr = 0;
//    for (int i = 1; i <= q; i++) {
//        int jobl = query[i].l;
//        int jobr = query[i].r;
//        int id = query[i].id;
//        while (winl > jobl) {
//            add(arr[--winl]);
//        }
//        while (winr < jobr) {
//            add(arr[++winr]);
//        }
//        while (winl < jobl) {
//            del(arr[winl++]);
//        }
//        while (winr > jobr) {
//            del(arr[winr--]);
//        }
//        if (!hasSet[id]) {
//            hasSet[id] = true;
//            bitSet[id] = curSet;
//        } else {
//            bitSet[id] &= curSet;
//        }
//    }
//}
//
//void prepare() {
//    for (int i = 1; i <= n; i++) {
//        sorted[i] = arr[i];
//    }
//    sort(sorted + 1, sorted + n + 1);
//    for (int i = 1; i <= n; i++) {
//        arr[i] = kth(arr[i]);
//    }
//    int blen = (int)sqrt(n);
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    for (int t = MAXT - 1; m > 0; m -= t) {
//        int k = min(m, t);
//        memset(cnt, 0, sizeof(int) * (n + 2));
//        memset(hasSet, 0, sizeof(bool) * (k + 2));
//        memset(ans, 0, sizeof(int) * (k + 2));
//        curSet.reset();
//        int cntq = 0, l, r;
//        for (int i = 1; i <= k; i++) {
//            for (int j = 1; j <= 3; j++) {
//                cin >> l >> r;
//                query[++cntq] = { l, r, i };
//                ans[i] += r - l + 1;
//            }
//        }
//        sort(query + 1, query + cntq + 1, QueryCmp);
//        compute(cntq);
//        for (int i = 1; i <= k; i++) {
//            ans[i] -= bitSet[i].count() * 3;
//        }
//        for (int i = 1; i <= k; i++) {
//            cout << ans[i] << '\n';
//        }
//    }
//    return 0;
//}
